<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/19/11/" class="article-date">
  <time class="dt-published" datetime="2021-10-19T08:18:04.000Z" itemprop="datePublished">2021-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/19/11/">11</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/19/11/" data-id="ckuxyexxv00006kvmdn0wdpl0" data-title="11" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/19/%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2021-10-19T08:06:04.141Z" itemprop="datePublished">2021-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="一、犀牛的使用（版本-4-x）"><a href="#一、犀牛的使用（版本-4-x）" class="headerlink" title="一、犀牛的使用（版本 4.x）"></a>一、犀牛的使用（版本 4.x）</h5><ol>
<li>拿到 .stp 模型文件用犀牛软件打开，分为四个版块（上视角、三维视角、前视角、右视角），如下图所示：</li>
</ol>
<p><img src="C:\Users\mc\Desktop\截图\01.png"></p>
<ol start="2">
<li><p>双击 <code>perspective </code> 进入三维视角版块，如下图：</p>
<p><img src="C:\Users\mc\Desktop\截图\02.png" alt="02"></p>
</li>
<li><p>选中模型，单机工具栏<code>爆炸</code>选项，将模型炸开成各零件，如下图：</p>
<p><img src="C:\Users\mc\Desktop\截图\03.png" alt="03"></p>
</li>
<li><p>右侧工具栏新建图层，用于区别各零件模型，对模型分层。如下图：</p>
<p><img src="C:\Users\mc\Desktop\截图\04.png" alt="04"></p>
</li>
<li><p>选中模型，对模型分层上色，操作如下图：<img src="file://C:/Users/mc/Desktop/%E6%88%AA%E5%9B%BE/05.png?lastModify=1634629455" alt="05"></p>
</li>
<li><p>导出模型，选择 <code>obj</code>格式导出。</p>
<p><img src="C:\Users\mc\Desktop\截图\06.png" alt="06"></p>
</li>
</ol>
<h5 id="二、模型渲染及操作"><a href="#二、模型渲染及操作" class="headerlink" title="二、模型渲染及操作"></a>二、模型渲染及操作</h5><ol>
<li>模型渲染官方库：<a href="">https://threejs.org/</a></li>
<li>官方案例：<a target="_blank" rel="noopener" href="https://threejs.org/examples/#webgl_animation_cloth">https://threejs.org/examples/#webgl_animation_cloth</a></li>
<li>官方教程：<a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/users/20107572/ironman/1782?page=2">https://ithelp.ithome.com.tw/users/20107572/ironman/1782?page=2</a></li>
<li> 其他借鉴：<a href="bookmarks_10_19_21.html">bookmarks_10_19_21.html</a> </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/19/%E6%93%8D%E4%BD%9C/" data-id="ckuxyexz6000j6kvm0jt11wnp" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-call、apply、bind" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/21/javascript%E7%B3%BB%E5%88%97-call%E3%80%81apply%E3%80%81bind/" class="article-date">
  <time class="dt-published" datetime="2021-06-21T00:43:23.000Z" itemprop="datePublished">2021-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/21/javascript%E7%B3%BB%E5%88%97-call%E3%80%81apply%E3%80%81bind/">javascript系列-call、apply、bind</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、call的实现"><a href="#一、call的实现" class="headerlink" title="一、call的实现"></a>一、call的实现</h3><ul>
<li>第一个参数为<code>null</code>或者<code>undefined</code>时，<code>this</code>指向<code>window</code>，值为原始值的指向该原始值的自动包装对象，如：String，Number，Boolean。</li>
<li>为了避免函数名与上下文<code>[context]</code>的属性命名相冲突，使用<code>Symbol</code>类型作为唯一值。</li>
<li>将函数作为传入的上下文<code>[context]</code>的属性执行。</li>
<li>函数执行完成后删除该属性。</li>
<li>返回执行的结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// ## call</span><br><span class="line">   Function.prototype.myCall = function (context, ...args) &#123;</span><br><span class="line">     // 1. 如果传入的context是null或undefined，则将window赋值给context</span><br><span class="line">     const ctx = context || window</span><br><span class="line"></span><br><span class="line">     // 2. 定义唯一标识，以免与context上的属性名冲突</span><br><span class="line">     const func = Symbol()</span><br><span class="line"></span><br><span class="line">     // 3. 将this赋值给ctx[func]</span><br><span class="line">     ctx[func] = this</span><br><span class="line"></span><br><span class="line">     // 4. 解析参数</span><br><span class="line">     args = args || []</span><br><span class="line"></span><br><span class="line">     // 5. 以对象的方式调用，此时this指向ctx</span><br><span class="line">     const res = args.length &gt; 0 ? ctx[func](args) : ctx[func]()</span><br><span class="line"></span><br><span class="line">     // 6. 删除该方法，否则会造成传入对象的污染</span><br><span class="line">     delete ctx[func]</span><br><span class="line"></span><br><span class="line">     // 6. 返回结果</span><br><span class="line">     return res</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 示例1</span><br><span class="line">   // let name = &#x27;mc&#x27;</span><br><span class="line">   // const person = &#123;</span><br><span class="line">   //   name: &#x27;小明&#x27;,</span><br><span class="line">   //   sayName: function () &#123;</span><br><span class="line">   //     console.log(this.name)</span><br><span class="line">   //   &#125;</span><br><span class="line">   // &#125;</span><br><span class="line">   // console.log(setTimeout(person.sayName, 0)) // mc</span><br><span class="line">   // console.log(setTimeout(person.sayName.bind(person), 0)) // 小明</span><br><span class="line">   // console.log(setTimeout(person.sayName.myCall(person), 0)) // 小明</span><br></pre></td></tr></table></figure>

<h3 id="二、apply的实现"><a href="#二、apply的实现" class="headerlink" title="二、apply的实现"></a>二、apply的实现</h3><ul>
<li>前面实现和call一样。</li>
<li>第二个参数可以传或者不传，参数必须是数组或者类数组。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context, args = []) &#123;</span><br><span class="line">  const ctx = context || window;</span><br><span class="line"></span><br><span class="line">  const func = Symbol();</span><br><span class="line">  ctx[func] = this;</span><br><span class="line"></span><br><span class="line">  const res = args.length &gt; 0 ? ctx[func](...args) : ctx[func]();</span><br><span class="line"></span><br><span class="line">  delete ctx[func];</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(setTimeout(person.sayName.myApply(person), 0)) // 小明</span><br></pre></td></tr></table></figure>

<h3 id="三、bind的实现"><a href="#三、bind的实现" class="headerlink" title="三、bind的实现"></a>三、bind的实现</h3><p>​    考虑：</p>
<ul>
<li><code>bind()</code>除了<code>this</code>外，还可以传入多个参数。</li>
<li><code>bind</code>新创建的函数可能传入多个参数。</li>
<li>新函数可能被当做构造函数执行。</li>
<li>函数可能有返回值。</li>
</ul>
<p>​    实现方法：</p>
<ul>
<li><code>bind</code>方法不会立即执行，会返回一个待执行的函数：（闭包）。</li>
<li>实现作用域绑定（apply）。</li>
<li>参数传递（apply数组传参）。</li>
<li>作为构造函数时，作为原型继承。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// ## bind的实现</span><br><span class="line">    Function.prototype.myBind = function (context, ...args) &#123;</span><br><span class="line">      </span><br><span class="line">      // 1. 创建一个变量赋值为this，表示为当前函数</span><br><span class="line">      const fn = this</span><br><span class="line"></span><br><span class="line">      // 2. 判断有没有传参进来，若没有传参赋值为[]</span><br><span class="line">      args = args || []</span><br><span class="line"></span><br><span class="line">      // 3. 返回一个newFn函数，在里面调用fn函数</span><br><span class="line">      return function newFn (...newFnArgs) &#123;</span><br><span class="line">        if (this instanceof newFn) &#123;</span><br><span class="line">          return new fn(...args, ...newFnArgs)</span><br><span class="line">        &#125;</span><br><span class="line">        return fn.apply(context, [...args, ...newFnArgs])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let name = &#x27;mc&#x27;</span><br><span class="line">    const person = &#123;</span><br><span class="line">      name: &#x27;小明&#x27;,</span><br><span class="line">      sayName: function () &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(setTimeout(person.sayName.myBind(person)(), 0)) // 小明</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/21/javascript%E7%B3%BB%E5%88%97-call%E3%80%81apply%E3%80%81bind/" data-id="ckuxyexyc00036kvmhjxh57p5" data-title="javascript系列-call、apply、bind" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-ajax" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/17/javascript%E7%B3%BB%E5%88%97-ajax/" class="article-date">
  <time class="dt-published" datetime="2021-06-17T00:38:33.000Z" itemprop="datePublished">2021-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/17/javascript%E7%B3%BB%E5%88%97-ajax/">javascript系列-ajax</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>​    <code>ajax</code>(Async Javascript and XML)，即异步的<code>javascript</code>和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新刷新整个网页的情况下，与服务器交换数据，更新部分网页。</p>
<p>​    原理：通过<code>XMLHttpRequest</code>对象向服务器发异步请求，从服务器获得数据，然后用<code>javascript</code>操作<code>DOM</code>来更新界面。</p>
<h3 id="二、实现过程"><a href="#二、实现过程" class="headerlink" title="二、实现过程"></a>二、实现过程</h3><ul>
<li>创建<code>XMLHttpRequest</code>对象。</li>
<li>通过<code>XMLHttpRequest</code>对象的<code>open</code>方法与服务端建立连接。</li>
<li>构建请求所需要的数据，通过<code>XMLHttpRequest</code>对象的<code>send</code>方法发送给服务器。</li>
<li>通过<code>XMLHttpRequest</code>对象的<code>onreadystatechange</code>事件监听服务器端对你的通信状态。</li>
<li>接收并处理服务器端响应的数据。</li>
<li>将响应的数据反应到<code>DOM</code>上。</li>
</ul>
<h3 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function ajax (options) &#123;</span><br><span class="line">       // 创建一个XMLHttpRequest</span><br><span class="line">       const xhr = new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">       // 初始化参数内容</span><br><span class="line">       options = options || &#123;&#125;</span><br><span class="line">       options.method = (options.method || &#x27;GET&#x27;).toUpperCase();</span><br><span class="line">       options.dataType = options.dataType || &#x27;json&#x27;;</span><br><span class="line">       const params = options.data;</span><br><span class="line"></span><br><span class="line">       // 发送请求</span><br><span class="line">       if(options.method === &#x27;GET&#x27;) &#123;</span><br><span class="line">         xhr.open(&#x27;GET&#x27;, options.url + &#x27;?&#x27; + params, true);</span><br><span class="line">         xhr.send(null);</span><br><span class="line">       &#125;else if(options.method === &#x27;POST&#x27;) &#123;</span><br><span class="line">         xhr.open(&#x27;POST&#x27;, options.url, true);</span><br><span class="line">         xhr.send(params);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       // 接收请求</span><br><span class="line">       xhr.onreadystatechange = function() &#123;</span><br><span class="line">         if(xhr.readyState === 4) &#123;</span><br><span class="line">           const status = xhr.status;</span><br><span class="line">           if(status &gt;= 200 &amp;&amp; status &lt; 300) &#123;</span><br><span class="line">             options.success &amp;&amp;  options.success(xhr.responseText, xhr.responseXml);</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">             options.fail &amp;&amp;  options.fail(status);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ajax(&#123;</span><br><span class="line">       method: &#x27;post&#x27;,</span><br><span class="line">       url: &#x27;https:www.baidu.com&#x27;,</span><br><span class="line">       dataType: &#x27;json&#x27;,</span><br><span class="line">       data: &#123;&#125;,</span><br><span class="line">       success (text, xml) &#123;</span><br><span class="line">         // 请求成功后的回调函数</span><br><span class="line">         console.log(text)</span><br><span class="line">       &#125;,</span><br><span class="line">       fail (status) &#123;</span><br><span class="line">         // 请求失败后的回调函数</span><br><span class="line">         console.log(status)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   </span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/17/javascript%E7%B3%BB%E5%88%97-ajax/" data-id="ckuxyexya00026kvm2xmo82e1" data-title="javascript系列-ajax" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-new操作符" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/16/javascript%E7%B3%BB%E5%88%97-new%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="article-date">
  <time class="dt-published" datetime="2021-06-16T00:36:40.000Z" itemprop="datePublished">2021-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/16/javascript%E7%B3%BB%E5%88%97-new%E6%93%8D%E4%BD%9C%E7%AC%A6/">javascript系列-new操作符</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>​    <code>new</code>操作符用来创建给定构造函数的实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  // return 1;</span><br><span class="line">  return &#123;age: 24&#125;;</span><br><span class="line">&#125;</span><br><span class="line">const person = new Person(&#x27;mc&#x27;);</span><br><span class="line">console.log(person);    </span><br><span class="line">console.log(person.name);</span><br></pre></td></tr></table></figure>

<p>​    构造函数也可以返回值，当返回值的是基础数据类型时，实例对象是可以访问到<code>name</code>属性的；当返回值是引用数据类型时，实例对象是返回的引用值，不能访问到<code>name</code>属性。</p>
<h3 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h3><p>​    具体流程如下：</p>
<ol>
<li>在内存中创建了一个新对象。</li>
<li>这个对象的内部<code>[[prototype]]</code>被赋值为构造函数的<code>prototype</code>属性。</li>
<li>构造函数内部的<code>this</code>被赋值为这个新对象，即<code>this</code>指向这个新对象。</li>
<li>执行构造函数内部的代码（给新对象添加属性）。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的对象。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 实现一个new操作符</span><br><span class="line">function myNew(Func, ...args) &#123;</span><br><span class="line">  // 1. 创建一个新对象</span><br><span class="line">  const obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // 2. 新对象的[[prototype]]被赋值为构造函数的prototype</span><br><span class="line">  obj.__proto__ = Func.prototype;</span><br><span class="line"></span><br><span class="line">  // 3. 构造函数的this指向这个新对象</span><br><span class="line">  let result = Func.apply(obj, args);</span><br><span class="line"></span><br><span class="line">  // 4. 根据返回值返回结果</span><br><span class="line">  return result instanceof Object ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = myNew(Person, &#x27;mc&#x27;, 24);</span><br><span class="line">console.log(p);       // Person &#123; name: &#x27;mc&#x27;, age: 24 &#125;</span><br><span class="line">console.log(p.name);  // mc</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/16/javascript%E7%B3%BB%E5%88%97-new%E6%93%8D%E4%BD%9C%E7%AC%A6/" data-id="ckuxyexyh00056kvmhf7y0k46" data-title="javascript系列-new操作符" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-事件代理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/15/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-06-15T00:43:45.000Z" itemprop="datePublished">2021-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/15/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/">javascript系列-事件代理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>​    把一个元素响应事件（click，keydown…）的函数委托到另一个元素。</p>
<p>​    事件委托会把一组或者一个事件绑定到父级或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素。</p>
<h3 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">   &lt;li&gt;按钮1&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;按钮2&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;按钮3&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;按钮4&lt;/li&gt;</span><br><span class="line">   &lt;li&gt;按钮5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 耗性能</span><br><span class="line">   const lis = document.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">   for(let i=0; i&lt;lis.length; i++) &#123;</span><br><span class="line">     lis[i].onclick = function(e) &#123;</span><br><span class="line">       console.log(e.target.innerHTML);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 2. 给父层元素</span><br><span class="line">document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function(e) &#123;</span><br><span class="line">  // 兼容性处理</span><br><span class="line">  const event = e || window.event;</span><br><span class="line">  const target = event.target || event.srcElement;</span><br><span class="line"></span><br><span class="line">  // 判断是否匹配目标元素</span><br><span class="line">  if(target.nodeName.toLocaleLowerCase() === &#x27;li&#x27;) &#123;</span><br><span class="line">    console.log(target.nodeName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>​    适合事件委托的事件有：<code>click</code>、<code>mousedown</code>、<code>mouseup</code>、<code>keydown</code>、<code>keyup</code>、<code>keypress</code></p>
<p>​    优点：</p>
<ul>
<li><p>减少整个页面的内存，提升性能</p>
</li>
<li><p>动态绑定，减少重复</p>
</li>
</ul>
<p>​    局限性：</p>
<ul>
<li><code>focus</code>、<code>blur</code>这些事件没有事件冒泡机制，所以无法进行委托绑定事件</li>
<li><code>mousemove</code>、<code>mouseout</code>这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/15/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/" data-id="ckuxyexyk00066kvmdnpf9zty" data-title="javascript系列-事件代理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-typeof和instanceof" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/11/javascript%E7%B3%BB%E5%88%97-typeof%E5%92%8Cinstanceof/" class="article-date">
  <time class="dt-published" datetime="2021-06-11T00:38:45.000Z" itemprop="datePublished">2021-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/11/javascript%E7%B3%BB%E5%88%97-typeof%E5%92%8Cinstanceof/">javascript系列-typeof和instanceof</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、typeof操作符"><a href="#一、typeof操作符" class="headerlink" title="一、typeof操作符"></a>一、typeof操作符</h3><p>​    <code>typeof</code>操作符返回一个字符串，表示未经计算的操作数的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof 1);              // &quot;number&quot;</span><br><span class="line">console.log(typeof &#x27;1&#x27;);            // &quot;string&quot;</span><br><span class="line">console.log(typeof undefined);      // &quot;undefined&quot;</span><br><span class="line">console.log(typeof true);           // &quot;boolean&quot;</span><br><span class="line">console.log(typeof Symbol());       // &quot;symbol&quot;</span><br><span class="line">console.log(typeof null);           // &quot;object&quot;</span><br><span class="line">console.log(typeof []);             // &quot;object&quot;</span><br><span class="line">console.log(typeof &#123;&#125;);             // &quot;object&quot;</span><br><span class="line">console.log(typeof console);        // &quot;object</span><br><span class="line">console.log(typeof console.log);    // &quot;function</span><br></pre></td></tr></table></figure>

<h3 id="二、instanceof操作符"><a href="#二、instanceof操作符" class="headerlink" title="二、instanceof操作符"></a>二、instanceof操作符</h3><p>​    <code>instanceof</code>操作符用来确定一个对象实例的原型链上是否有原型。</p>
<p>​    使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object instanceof constructor</span><br></pre></td></tr></table></figure>

<p>​    构造函数可以通过<code>new</code>操作符实例化对象，<code>instanceof</code>能判断这个对象是否是之前那个构造函数生成的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  // 1. 先判断是否是基本数据类型</span><br><span class="line">  if(typeof left !== &#x27;object&#x27; || left === null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 2. 获取到实例的原型</span><br><span class="line">  let proto = Object.getPrototypeOf(left);</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    if(proto === null) return false;      // 找到Object顶层</span><br><span class="line">    if(proto = right.prototype) return true;</span><br><span class="line">    proto = Object.getPrototypeOf(proto); // 沿原型链查找，直到返回true或false</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125;</span><br><span class="line">const foo = new Foo();</span><br><span class="line">console.log(myInstanceof(foo, Foo));      // true</span><br></pre></td></tr></table></figure>

<h3 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h3><p>​    <code>typeof</code>和i<code>nstanceof</code>都是判断数据类型的方法，区别如下：</p>
<ul>
<li><p><code>typeof</code>返回一个变量的基本类型，<code>instanceof</code>返回的是布尔值。</p>
</li>
<li><p><code>instanceof</code>可以准确的判断复杂数据引用数据类型，但是不能判断基础数据类型。</p>
</li>
<li><p><code>typeof</code>虽然也能判断基础数据类型（<code>null</code>除外）,但是引用数据类型除<code>function</code>类型以外，其他的也不能判断。</p>
<p>可以看到以上两种方法都存在弊端，并不能满足所有场景；如果需要通用检测数据类型，可以使用<code>Object.prototype.toString</code>，调用该方法，统一返回格式<code>&quot;[object xxx]&quot;</code>的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString(&#123;&#125;));               // [object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(&#x27;&#x27;));          // [object String]</span><br><span class="line">console.log(Object.prototype.toString.call(1));           // [object Number]</span><br><span class="line">console.log(Object.prototype.toString.call(true));        // [object Boolean]</span><br><span class="line">console.log(Object.prototype.toString.call(null));        // [object Null]</span><br><span class="line">console.log(Object.prototype.toString.call([]));          // [object Array]</span><br><span class="line">console.log(Object.prototype.toString.call(undefined));   // [object Undefined]</span><br><span class="line">console.log(Object.prototype.toString.call(/123/g));      // [object RegExp]</span><br><span class="line">console.log(Object.prototype.toString.call(new Date()));  // [object Date]</span><br><span class="line">console.log(Object.prototype.toString.call(document));    // [object HTMLDocument]</span><br><span class="line">console.log(Object.prototype.toString.call(window));      // [object Window]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>自己封装一个全局通用判断类型的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 封装一个getType方法来检测</span><br><span class="line">function getType(obj) &#123;</span><br><span class="line">  let type = typeof obj;</span><br><span class="line">  // 先检测是否是基本数据类型，是基本数据类型直接返回</span><br><span class="line">  if(type !== &#x27;object&#x27;) &#123;</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 对obj是复杂数据类型再进行操作</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &#x27;$1&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getType(null));   // Null</span><br><span class="line">console.log(getType(&#123;&#125;));     // Object</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/11/javascript%E7%B3%BB%E5%88%97-typeof%E5%92%8Cinstanceof/" data-id="ckuxyexyp00096kvm9qipafu0" data-title="javascript系列-typeof和instanceof" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-事件模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/10/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-10T00:37:38.000Z" itemprop="datePublished">2021-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/10/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/">javascript系列-事件模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、事件与事件流"><a href="#一、事件与事件流" class="headerlink" title="一、事件与事件流"></a>一、事件与事件流</h3><p>​    <code>javascript</code>与<code>HTML</code>交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。可以使用仅在事件发生时执行的<code>监听器</code>（也叫处理程序）订阅事件。</p>
<p>​    <code>事件流</code>描述了页面接收事件的顺序。</p>
<p>​    事件流会经历三个阶段：</p>
<ul>
<li>事件捕获阶段（Capture Phase）</li>
<li>处于目标阶段（Targer Phase）</li>
<li>事件冒泡阶段（Bubbling Phase）</li>
</ul>
<h4 id="1-事件冒泡阶段"><a href="#1-事件冒泡阶段" class="headerlink" title="1. 事件冒泡阶段"></a>1. 事件冒泡阶段</h4><p>​    IE事件流被称为<code>事件冒泡</code>，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始接触，然后向上传播至没有那么具体的元素（文档）。</p>
<p>​    现代浏览器的事件会一直冒泡到<code>window</code>对象。</p>
<h4 id="2-事件捕获阶段"><a href="#2-事件捕获阶段" class="headerlink" title="2. 事件捕获阶段"></a>2. 事件捕获阶段</h4><p>​    <code>事件捕获</code>的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。</p>
<p>​    <code>事件捕获</code>为提前拦截事件提供了可能。</p>
<h4 id="3-处于目标阶段"><a href="#3-处于目标阶段" class="headerlink" title="3. 处于目标阶段"></a>3. 处于目标阶段</h4><h3 id="二、事件模型"><a href="#二、事件模型" class="headerlink" title="二、事件模型"></a>二、事件模型</h3><h4 id="1-原始事件模型（DOM0级）"><a href="#1-原始事件模型（DOM0级）" class="headerlink" title="1. 原始事件模型（DOM0级）"></a>1. 原始事件模型（DOM0级）</h4><p>​    事件绑定监听函数比较简单，有两种方式：</p>
<ul>
<li><p>HTML代码中直接绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&quot;fun()&quot;&gt;click&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>通过JS代码绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.onclick = fn;</span><br></pre></td></tr></table></figure>

<p>特点：绑定速度快</p>
<p><code>DOM0</code>级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行。</p>
<ul>
<li>只支持冒泡，不支持捕获</li>
<li>同一个类型的事件只能绑定一次</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; onclick=&quot;fun1()&quot;&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.getElementById(&#x27;.btn&#x27;);</span><br><span class="line">btn.onclick = fun2;</span><br></pre></td></tr></table></figure>

<p>如上，当希望为同一个元素绑定多个同类型事件的时候（上面的这个<code>btn</code>元素绑定2个点击事件），是不被允许的，后绑定的事件会覆盖之前的事件</p>
<p>删除 <code>DOM0</code> 级事件处理程序只要将对应事件属性置为<code>null</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = null;</span><br></pre></td></tr></table></figure>

<h3 id="标准事件模型"><a href="#标准事件模型" class="headerlink" title="标准事件模型"></a>标准事件模型</h3><p>在该事件模型中，一次事件共有三个过程:</p>
<ul>
<li>事件捕获阶段：事件从<code>document</code>一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
<li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</li>
<li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
</ul>
<p>事件绑定监听函数的方式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure>

<p>事件移除监听函数的方式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure>

<p>参数如下：</p>
<ul>
<li><code>eventType</code>指定事件类型(不要加on)</li>
<li><code>handler</code>是事件处理函数</li>
<li><code>useCapture</code>是一个<code>boolean</code>用于指定是否在捕获阶段进行处理，一般设置为<code>false</code>与IE浏览器保持一致</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&#x27;.btn&#x27;);</span><br><span class="line">btn.addEventListener(‘click’, showMessage, false);</span><br><span class="line">btn.removeEventListener(‘click’, showMessage, false);</span><br></pre></td></tr></table></figure>

<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>可以在一个<code>DOM</code>元素上绑定多个事件处理器，各自并不会冲突</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(‘click’, showMessage1, false);</span><br><span class="line">btn.addEventListener(‘click’, showMessage2, false);</span><br><span class="line">btn.addEventListener(‘click’, showMessage3, false);</span><br></pre></td></tr></table></figure>

<ul>
<li>执行时机</li>
</ul>
<p>当第三个参数(<code>useCapture</code>)设置为<code>true</code>就在捕获过程中执行，反之在冒泡过程中执行处理函数</p>
<p>下面举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&#x27;div&#x27;&gt;</span><br><span class="line">    &lt;p id=&#x27;p&#x27;&gt;</span><br><span class="line">        &lt;span id=&#x27;span&#x27;&gt;Click Me!&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>设置点击事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var div = document.getElementById(&#x27;div&#x27;);</span><br><span class="line">var p = document.getElementById(&#x27;p&#x27;);</span><br><span class="line"></span><br><span class="line">function onClickFn (event) &#123;</span><br><span class="line">    var tagName = event.currentTarget.tagName;</span><br><span class="line">    var phase = event.eventPhase;</span><br><span class="line">    console.log(tagName, phase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#x27;click&#x27;, onClickFn, false);</span><br><span class="line">p.addEventListener(&#x27;click&#x27;, onClickFn, false);</span><br></pre></td></tr></table></figure>

<p>上述使用了<code>eventPhase</code>，返回一个代表当前执行阶段的整数值。1为捕获阶段、2为事件对象触发阶段、3为冒泡阶段</p>
<p>点击<code>Click Me!</code>，输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P 3</span><br><span class="line">DIV 3</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>p</code>和<code>div</code>都是在冒泡阶段响应了事件，由于冒泡的特性，裹在里层的<code>p</code>率先做出响应</p>
<p>如果把第三个参数都改为<code>true</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#x27;click&#x27;, onClickFn, true);</span><br><span class="line">p.addEventListener(&#x27;click&#x27;, onClickFn, true);</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DIV 1</span><br><span class="line">P 1</span><br></pre></td></tr></table></figure>

<p>两者都是在捕获阶段响应事件，所以<code>div</code>比<code>p</code>标签先做出响应</p>
<h3 id="IE事件模型"><a href="#IE事件模型" class="headerlink" title="IE事件模型"></a>IE事件模型</h3><p>IE事件模型共有两个过程:</p>
<ul>
<li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</li>
<li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
</ul>
<p>事件绑定监听函数的方式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attachEvent(eventType, handler)</span><br></pre></td></tr></table></figure>

<p>事件移除监听函数的方式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detachEvent(eventType, handler)</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&#x27;.btn&#x27;);</span><br><span class="line">btn.attachEvent(‘onclick’, showMessage);</span><br><span class="line">btn.detachEvent(‘onclick’, showMessage);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/10/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/" data-id="ckuxyexym00076kvmfny6cpax" data-title="javascript系列-事件模型" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-执行上下文和执行栈-js" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/09/javascript%E7%B3%BB%E5%88%97-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-js/" class="article-date">
  <time class="dt-published" datetime="2021-06-09T00:44:18.000Z" itemprop="datePublished">2021-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/09/javascript%E7%B3%BB%E5%88%97-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-js/">javascript系列-执行上下文和执行栈.js</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、执行上下文"><a href="#一、执行上下文" class="headerlink" title="一、执行上下文"></a>一、执行上下文</h3><p>​    执行上下文是对<code>javascript</code>代码执行环境的一种抽象概念，只要有<code>javascript</code>代码运行，那么它一定在执行上下文中。</p>
<ul>
<li><p>全局执行上下文：只有一个，浏览器中的全局对象就是<code>window</code></p>
</li>
<li><p>函数执行上下文：有无数个，函数只有被调用的时候才会创建，每次调用都会创建一个新的执行上下文。</p>
</li>
<li><p>Eval函数执行上下文：指的是在<code>eval</code>函数中运行的代码。</p>
<p>只有全局上下文中的变量能被任何执行上下文访问。</p>
<p>每次调用函数创建一个新的执行上下文，会创建一个私有作用域，函数内部声明的变量不能在当前函数作用域以外的作用域访问。</p>
</li>
</ul>
<h3 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h3><p>​    执行上下文的生命周期包含三个阶段：创建阶段—–&gt; 执行阶段 —–&gt; 回收阶段</p>
<h4 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1. 创建阶段"></a>1. 创建阶段</h4><p>​    创建阶段即函数被调用，但未执行其任何内部代码。</p>
<p>​    创建阶段做了三件事：</p>
<ul>
<li>确定了<code>this</code>的值，也被称为<code>This Binding</code></li>
<li>LexicalEnvironment（词法环境）组件被创建</li>
<li>VariableEnvironment（变量环境）组件被创建</li>
</ul>
<h5 id="1-This-Binding"><a href="#1-This-Binding" class="headerlink" title="1) This Binding"></a>1) This Binding</h5><p>​    确定This的值，This的值是在执行的时候才能确认，定义的时候不能确认。</p>
<h5 id="2-词法环境"><a href="#2-词法环境" class="headerlink" title="2) 词法环境"></a>2) 词法环境</h5><ul>
<li>全局环境：是一个没有外部环境的词法环境，其外部环境引用的是null，有一个全局对象，this引用的是这个全局对象。</li>
<li>函数环境：用户在函数中定义的变量被存储到环境记录中，包含了arguments对象，外部函数的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;  // 全局执行上下文</span><br><span class="line">  LexicalEnvironment: &#123;       // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;     // 环境记录</span><br><span class="line">      Type: &quot;Object&quot;,           // 全局环境</span><br><span class="line">      // 标识符绑定在这里 </span><br><span class="line">      outer: &lt;null&gt;           // 对外部环境的引用</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123; // 函数执行上下文</span><br><span class="line">  LexicalEnvironment: &#123;     // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;    // 环境记录</span><br><span class="line">      Type: &quot;Declarative&quot;,      // 函数环境</span><br><span class="line">      // 标识符绑定在这里      // 对外部环境的引用</span><br><span class="line">      outer: &lt;Global or outer function environment reference&gt;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3）变量环境"><a href="#3）变量环境" class="headerlink" title="3）变量环境"></a>3）变量环境</h5><p>​    变量环境也是一个词法环境，它具有上面定义的词法环境所有的属性。</p>
<p>​    在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ <code>let</code> 和 <code>const</code> ）绑定，而后者仅用于存储变量（ <code>var</code> ）绑定</p>
<h4 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2. 执行阶段"></a>2. 执行阶段</h4><p>​    在这阶段，执行变量赋值、代码执行</p>
<p>​    如果 <code>Javascript</code> 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 <code>undefined</code> 值。</p>
<h4 id="3-回收阶段"><a href="#3-回收阶段" class="headerlink" title="3. 回收阶段"></a>3. 回收阶段</h4><p>​    执行上下文出栈等待虚拟机回收执行上下文。</p>
<h3 id="三、执行栈"><a href="#三、执行栈" class="headerlink" title="三、执行栈"></a>三、执行栈</h3><p>​    执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。</p>
<p>​    当<code>Javascript</code>引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中。</p>
<p>​    每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中。</p>
<p>​    引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文。</p>
<p>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/09/javascript%E7%B3%BB%E5%88%97-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-js/" data-id="ckuxyexyx000d6kvm509vaita" data-title="javascript系列-执行上下文和执行栈.js" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascipt系列-this对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/07/javascipt%E7%B3%BB%E5%88%97-this%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2021-06-07T00:36:12.000Z" itemprop="datePublished">2021-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/07/javascipt%E7%B3%BB%E5%88%97-this%E5%AF%B9%E8%B1%A1/">javascipt系列-this对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>​    在标准函数中，this引用的是把函数当成方法调用的上下文对象，这时候通常称其为this值（在网页的全局上下文中调用函数时，this指向window对象）</p>
<p>​    this关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// this在函数执行过程中，一旦被确定，就不能再修改了</span><br><span class="line">var a = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  this = obj;               // 修改this运行会报错</span><br><span class="line">  console.log(this.a);      // SyntaxError: Invalid left-hand side in assignment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<h3 id="二、绑定规则"><a href="#二、绑定规则" class="headerlink" title="二、绑定规则"></a>二、绑定规则</h3><h4 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;mc&#x27;;</span><br><span class="line">function person() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line">console.log(person());  // mc</span><br></pre></td></tr></table></figure>

<p>this指向window，所以输出结果是mc；</p>
<!--注意：严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数在非严格模式下运行，默认绑定才能绑定到全局对象。-->

<h4 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h4><p>​    函数可以作为某个对象的方法调用，this指向上一级的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">  console.log(this.x);      // 1</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.x = 1;</span><br><span class="line">obj.test = test;</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>

<p>​    以下这个函数包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它的上一级对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  b: &#123;</span><br><span class="line">    fn: function() &#123;</span><br><span class="line">      console.log(this.a);	// undefined</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn();     </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  b: &#123;</span><br><span class="line">    a: 12,</span><br><span class="line">    fn: function() &#123;</span><br><span class="line">      console.log(this.a);      // undefined</span><br><span class="line">      console.log(this);        // window</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var j = o.b.fn;</span><br><span class="line">j();</span><br></pre></td></tr></table></figure>

<p>此时<code>this</code>指向的是<code>window</code>，这里的大家需要记住，<code>this</code>永远指向的是最后调用它的对象，虽然<code>fn</code>是对象<code>b</code>的方法，但是<code>fn</code>赋值给<code>j</code>时候并没有执行，所以最终指向<code>window</code>。</p>
<h4 id="3-new绑定"><a href="#3-new绑定" class="headerlink" title="3. new绑定"></a>3. new绑定</h4><p>​    通过构建函数<code>new</code>关键字生成一个实例对象，此时this指向这个实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Test() &#123;</span><br><span class="line">  this.x = 1;</span><br><span class="line">&#125;</span><br><span class="line">var obj = new Test();</span><br><span class="line">console.log(obj.x);   // 1</span><br></pre></td></tr></table></figure>

<p>​    <code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象。返回的是基本数据类型或者<code>null</code>，this仍指向实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fn() &#123;</span><br><span class="line">  this.x = 1;</span><br><span class="line">  // return &#123;&#125;;</span><br><span class="line">  // return 1;</span><br><span class="line">  return null</span><br><span class="line">&#125;</span><br><span class="line">var a = new Fn();</span><br><span class="line">console.log(a.x);   // undefined  1  1 </span><br></pre></td></tr></table></figure>

<h4 id="4-显式修改"><a href="#4-显式修改" class="headerlink" title="4. 显式修改"></a>4. 显式修改</h4><p>​    <code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">function Test() &#123;</span><br><span class="line"> console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.x = 1;</span><br><span class="line">obj.m = Test;</span><br><span class="line">obj.m();   // 1</span><br><span class="line">obj.m.call(obj);   // 1</span><br></pre></td></tr></table></figure>

<h3 id="三、箭头函数"><a href="#三、箭头函数" class="headerlink" title="三、箭头函数"></a>三、箭头函数</h3><p>​    原型上添加方法时候，<code>this</code>指向<code>window</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Cat() &#123;&#125;</span><br><span class="line">Cat.prototype.sayHello = () =&gt; &#123;</span><br><span class="line">  console.log(this === window);  // true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const cat = new Cat();</span><br><span class="line">cat.sayHello();</span><br></pre></td></tr></table></figure>

<h3 id="四、优先级"><a href="#四、优先级" class="headerlink" title="四、优先级"></a>四、优先级</h3><p>​    new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/07/javascipt%E7%B3%BB%E5%88%97-this%E5%AF%B9%E8%B1%A1/" data-id="ckuxyexyf00046kvm7ei790zx" data-title="javascipt系列-this对象" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/19/11/">11</a>
          </li>
        
          <li>
            <a href="/2021/10/19/%E6%93%8D%E4%BD%9C/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/21/javascript%E7%B3%BB%E5%88%97-call%E3%80%81apply%E3%80%81bind/">javascript系列-call、apply、bind</a>
          </li>
        
          <li>
            <a href="/2021/06/17/javascript%E7%B3%BB%E5%88%97-ajax/">javascript系列-ajax</a>
          </li>
        
          <li>
            <a href="/2021/06/16/javascript%E7%B3%BB%E5%88%97-new%E6%93%8D%E4%BD%9C%E7%AC%A6/">javascript系列-new操作符</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>