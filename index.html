<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-javascript系列-typeof和instanceof" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/11/javascript%E7%B3%BB%E5%88%97-typeof%E5%92%8Cinstanceof/" class="article-date">
  <time class="dt-published" datetime="2021-06-11T00:38:45.000Z" itemprop="datePublished">2021-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/11/javascript%E7%B3%BB%E5%88%97-typeof%E5%92%8Cinstanceof/">javascript系列-typeof和instanceof</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、typeof操作符"><a href="#一、typeof操作符" class="headerlink" title="一、typeof操作符"></a>一、typeof操作符</h3><p>​    <code>typeof</code>操作符返回一个字符串，表示未经计算的操作数的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof 1);              // &quot;number&quot;</span><br><span class="line">console.log(typeof &#x27;1&#x27;);            // &quot;string&quot;</span><br><span class="line">console.log(typeof undefined);      // &quot;undefined&quot;</span><br><span class="line">console.log(typeof true);           // &quot;boolean&quot;</span><br><span class="line">console.log(typeof Symbol());       // &quot;symbol&quot;</span><br><span class="line">console.log(typeof null);           // &quot;object&quot;</span><br><span class="line">console.log(typeof []);             // &quot;object&quot;</span><br><span class="line">console.log(typeof &#123;&#125;);             // &quot;object&quot;</span><br><span class="line">console.log(typeof console);        // &quot;object</span><br><span class="line">console.log(typeof console.log);    // &quot;function</span><br></pre></td></tr></table></figure>

<h3 id="二、instanceof操作符"><a href="#二、instanceof操作符" class="headerlink" title="二、instanceof操作符"></a>二、instanceof操作符</h3><p>​    <code>instanceof</code>操作符用来确定一个对象实例的原型链上是否有原型。</p>
<p>​    使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object instanceof constructor</span><br></pre></td></tr></table></figure>

<p>​    构造函数可以通过<code>new</code>操作符实例化对象，<code>instanceof</code>能判断这个对象是否是之前那个构造函数生成的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  // 1. 先判断是否是基本数据类型</span><br><span class="line">  if(typeof left !== &#x27;object&#x27; || left === null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 2. 获取到实例的原型</span><br><span class="line">  let proto = Object.getPrototypeOf(left);</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    if(proto === null) return false;      // 找到Object顶层</span><br><span class="line">    if(proto = right.prototype) return true;</span><br><span class="line">    proto = Object.getPrototypeOf(proto); // 沿原型链查找，直到返回true或false</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125;</span><br><span class="line">const foo = new Foo();</span><br><span class="line">console.log(myInstanceof(foo, Foo));      // true</span><br></pre></td></tr></table></figure>

<h3 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h3><p>​    <code>typeof</code>和i<code>nstanceof</code>都是判断数据类型的方法，区别如下：</p>
<ul>
<li><p><code>typeof</code>返回一个变量的基本类型，<code>instanceof</code>返回的是布尔值。</p>
</li>
<li><p><code>instanceof</code>可以准确的判断复杂数据引用数据类型，但是不能判断基础数据类型。</p>
</li>
<li><p><code>typeof</code>虽然也能判断基础数据类型（<code>null</code>除外）,但是引用数据类型除<code>function</code>类型以外，其他的也不能判断。</p>
<p>可以看到以上两种方法都存在弊端，并不能满足所有场景；如果需要通用检测数据类型，可以使用<code>Object.prototype.toString</code>，调用该方法，统一返回格式<code>&quot;[object xxx]&quot;</code>的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString(&#123;&#125;));               // [object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(&#x27;&#x27;));          // [object String]</span><br><span class="line">console.log(Object.prototype.toString.call(1));           // [object Number]</span><br><span class="line">console.log(Object.prototype.toString.call(true));        // [object Boolean]</span><br><span class="line">console.log(Object.prototype.toString.call(null));        // [object Null]</span><br><span class="line">console.log(Object.prototype.toString.call([]));          // [object Array]</span><br><span class="line">console.log(Object.prototype.toString.call(undefined));   // [object Undefined]</span><br><span class="line">console.log(Object.prototype.toString.call(/123/g));      // [object RegExp]</span><br><span class="line">console.log(Object.prototype.toString.call(new Date()));  // [object Date]</span><br><span class="line">console.log(Object.prototype.toString.call(document));    // [object HTMLDocument]</span><br><span class="line">console.log(Object.prototype.toString.call(window));      // [object Window]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>自己封装一个全局通用判断类型的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 封装一个getType方法来检测</span><br><span class="line">function getType(obj) &#123;</span><br><span class="line">  let type = typeof obj;</span><br><span class="line">  // 先检测是否是基本数据类型，是基本数据类型直接返回</span><br><span class="line">  if(type !== &#x27;object&#x27;) &#123;</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 对obj是复杂数据类型再进行操作</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &#x27;$1&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(getType(null));   // Null</span><br><span class="line">console.log(getType(&#123;&#125;));     // Object</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/11/javascript%E7%B3%BB%E5%88%97-typeof%E5%92%8Cinstanceof/" data-id="ckprpfkhu0000w8vm4s4b9437" data-title="javascript系列-typeof和instanceof" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-事件模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/10/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-10T00:37:38.000Z" itemprop="datePublished">2021-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/10/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/">javascript系列-事件模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、事件与事件流"><a href="#一、事件与事件流" class="headerlink" title="一、事件与事件流"></a>一、事件与事件流</h3><p>​    <code>javascript</code>与<code>HTML</code>交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。可以使用仅在事件发生时执行的<code>监听器</code>（也叫处理程序）订阅事件。</p>
<p>​    <code>事件流</code>描述了页面接收事件的顺序。</p>
<p>​    事件流会经历三个阶段：</p>
<ul>
<li>事件捕获阶段（Capture Phase）</li>
<li>处于目标阶段（Targer Phase）</li>
<li>事件冒泡阶段（Bubbling Phase）</li>
</ul>
<h4 id="1-事件冒泡阶段"><a href="#1-事件冒泡阶段" class="headerlink" title="1. 事件冒泡阶段"></a>1. 事件冒泡阶段</h4><p>​    IE事件流被称为<code>事件冒泡</code>，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始接触，然后向上传播至没有那么具体的元素（文档）。</p>
<p>​    现代浏览器的事件会一直冒泡到<code>window</code>对象。</p>
<h4 id="2-事件捕获阶段"><a href="#2-事件捕获阶段" class="headerlink" title="2. 事件捕获阶段"></a>2. 事件捕获阶段</h4><p>​    <code>事件捕获</code>的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。</p>
<p>​    <code>事件捕获</code>为提前拦截事件提供了可能。</p>
<h4 id="3-处于目标阶段"><a href="#3-处于目标阶段" class="headerlink" title="3. 处于目标阶段"></a>3. 处于目标阶段</h4><h3 id="二、事件模型"><a href="#二、事件模型" class="headerlink" title="二、事件模型"></a>二、事件模型</h3><h4 id="1-原始事件模型（DOM0级）"><a href="#1-原始事件模型（DOM0级）" class="headerlink" title="1. 原始事件模型（DOM0级）"></a>1. 原始事件模型（DOM0级）</h4><p>​    事件绑定监听函数比较简单，有两种方式：</p>
<ul>
<li><p>HTML代码中直接绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&quot;fun()&quot;&gt;click&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>通过JS代码绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.onclick = fn;</span><br></pre></td></tr></table></figure>

<p>特点：绑定速度快</p>
<p><code>DOM0</code>级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行。</p>
<ul>
<li>只支持冒泡，不支持捕获</li>
<li>同一个类型的事件只能绑定一次</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; onclick=&quot;fun1()&quot;&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.getElementById(&#x27;.btn&#x27;);</span><br><span class="line">btn.onclick = fun2;</span><br></pre></td></tr></table></figure>

<p>如上，当希望为同一个元素绑定多个同类型事件的时候（上面的这个<code>btn</code>元素绑定2个点击事件），是不被允许的，后绑定的事件会覆盖之前的事件</p>
<p>删除 <code>DOM0</code> 级事件处理程序只要将对应事件属性置为<code>null</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = null;</span><br></pre></td></tr></table></figure>

<h3 id="标准事件模型"><a href="#标准事件模型" class="headerlink" title="标准事件模型"></a>标准事件模型</h3><p>在该事件模型中，一次事件共有三个过程:</p>
<ul>
<li>事件捕获阶段：事件从<code>document</code>一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
<li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</li>
<li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
</ul>
<p>事件绑定监听函数的方式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure>

<p>事件移除监听函数的方式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure>

<p>参数如下：</p>
<ul>
<li><code>eventType</code>指定事件类型(不要加on)</li>
<li><code>handler</code>是事件处理函数</li>
<li><code>useCapture</code>是一个<code>boolean</code>用于指定是否在捕获阶段进行处理，一般设置为<code>false</code>与IE浏览器保持一致</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&#x27;.btn&#x27;);</span><br><span class="line">btn.addEventListener(‘click’, showMessage, false);</span><br><span class="line">btn.removeEventListener(‘click’, showMessage, false);</span><br></pre></td></tr></table></figure>

<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>可以在一个<code>DOM</code>元素上绑定多个事件处理器，各自并不会冲突</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(‘click’, showMessage1, false);</span><br><span class="line">btn.addEventListener(‘click’, showMessage2, false);</span><br><span class="line">btn.addEventListener(‘click’, showMessage3, false);</span><br></pre></td></tr></table></figure>

<ul>
<li>执行时机</li>
</ul>
<p>当第三个参数(<code>useCapture</code>)设置为<code>true</code>就在捕获过程中执行，反之在冒泡过程中执行处理函数</p>
<p>下面举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&#x27;div&#x27;&gt;</span><br><span class="line">    &lt;p id=&#x27;p&#x27;&gt;</span><br><span class="line">        &lt;span id=&#x27;span&#x27;&gt;Click Me!&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>设置点击事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var div = document.getElementById(&#x27;div&#x27;);</span><br><span class="line">var p = document.getElementById(&#x27;p&#x27;);</span><br><span class="line"></span><br><span class="line">function onClickFn (event) &#123;</span><br><span class="line">    var tagName = event.currentTarget.tagName;</span><br><span class="line">    var phase = event.eventPhase;</span><br><span class="line">    console.log(tagName, phase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#x27;click&#x27;, onClickFn, false);</span><br><span class="line">p.addEventListener(&#x27;click&#x27;, onClickFn, false);</span><br></pre></td></tr></table></figure>

<p>上述使用了<code>eventPhase</code>，返回一个代表当前执行阶段的整数值。1为捕获阶段、2为事件对象触发阶段、3为冒泡阶段</p>
<p>点击<code>Click Me!</code>，输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P 3</span><br><span class="line">DIV 3</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>p</code>和<code>div</code>都是在冒泡阶段响应了事件，由于冒泡的特性，裹在里层的<code>p</code>率先做出响应</p>
<p>如果把第三个参数都改为<code>true</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#x27;click&#x27;, onClickFn, true);</span><br><span class="line">p.addEventListener(&#x27;click&#x27;, onClickFn, true);</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DIV 1</span><br><span class="line">P 1</span><br></pre></td></tr></table></figure>

<p>两者都是在捕获阶段响应事件，所以<code>div</code>比<code>p</code>标签先做出响应</p>
<h3 id="IE事件模型"><a href="#IE事件模型" class="headerlink" title="IE事件模型"></a>IE事件模型</h3><p>IE事件模型共有两个过程:</p>
<ul>
<li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</li>
<li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
</ul>
<p>事件绑定监听函数的方式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attachEvent(eventType, handler)</span><br></pre></td></tr></table></figure>

<p>事件移除监听函数的方式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detachEvent(eventType, handler)</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&#x27;.btn&#x27;);</span><br><span class="line">btn.attachEvent(‘onclick’, showMessage);</span><br><span class="line">btn.detachEvent(‘onclick’, showMessage);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/10/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/" data-id="ckprpfki00001w8vm3gqea7ug" data-title="javascript系列-事件模型" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-执行上下文和执行栈-js" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/09/javascript%E7%B3%BB%E5%88%97-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-js/" class="article-date">
  <time class="dt-published" datetime="2021-06-09T00:44:18.000Z" itemprop="datePublished">2021-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/09/javascript%E7%B3%BB%E5%88%97-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-js/">javascript系列-执行上下文和执行栈.js</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、执行上下文"><a href="#一、执行上下文" class="headerlink" title="一、执行上下文"></a>一、执行上下文</h3><p>​    执行上下文是对<code>javascript</code>代码执行环境的一种抽象概念，只要有<code>javascript</code>代码运行，那么它一定在执行上下文中。</p>
<ul>
<li><p>全局执行上下文：只有一个，浏览器中的全局对象就是<code>window</code></p>
</li>
<li><p>函数执行上下文：有无数个，函数只有被调用的时候才会创建，每次调用都会创建一个新的执行上下文。</p>
</li>
<li><p>Eval函数执行上下文：指的是在<code>eval</code>函数中运行的代码。</p>
<p>只有全局上下文中的变量能被任何执行上下文访问。</p>
<p>每次调用函数创建一个新的执行上下文，会创建一个私有作用域，函数内部声明的变量不能在当前函数作用域以外的作用域访问。</p>
</li>
</ul>
<h3 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h3><p>​    执行上下文的生命周期包含三个阶段：创建阶段—–&gt; 执行阶段 —–&gt; 回收阶段</p>
<h4 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1. 创建阶段"></a>1. 创建阶段</h4><p>​    创建阶段即函数被调用，但未执行其任何内部代码。</p>
<p>​    创建阶段做了三件事：</p>
<ul>
<li>确定了<code>this</code>的值，也被称为<code>This Binding</code></li>
<li>LexicalEnvironment（词法环境）组件被创建</li>
<li>VariableEnvironment（变量环境）组件被创建</li>
</ul>
<h5 id="1-This-Binding"><a href="#1-This-Binding" class="headerlink" title="1) This Binding"></a>1) This Binding</h5><p>​    确定This的值，This的值是在执行的时候才能确认，定义的时候不能确认。</p>
<h5 id="2-词法环境"><a href="#2-词法环境" class="headerlink" title="2) 词法环境"></a>2) 词法环境</h5><ul>
<li>全局环境：是一个没有外部环境的词法环境，其外部环境引用的是null，有一个全局对象，this引用的是这个全局对象。</li>
<li>函数环境：用户在函数中定义的变量被存储到环境记录中，包含了arguments对象，外部函数的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;  // 全局执行上下文</span><br><span class="line">  LexicalEnvironment: &#123;       // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;     // 环境记录</span><br><span class="line">      Type: &quot;Object&quot;,           // 全局环境</span><br><span class="line">      // 标识符绑定在这里 </span><br><span class="line">      outer: &lt;null&gt;           // 对外部环境的引用</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123; // 函数执行上下文</span><br><span class="line">  LexicalEnvironment: &#123;     // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;    // 环境记录</span><br><span class="line">      Type: &quot;Declarative&quot;,      // 函数环境</span><br><span class="line">      // 标识符绑定在这里      // 对外部环境的引用</span><br><span class="line">      outer: &lt;Global or outer function environment reference&gt;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3）变量环境"><a href="#3）变量环境" class="headerlink" title="3）变量环境"></a>3）变量环境</h5><p>​    变量环境也是一个词法环境，它具有上面定义的词法环境所有的属性。</p>
<p>​    在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ <code>let</code> 和 <code>const</code> ）绑定，而后者仅用于存储变量（ <code>var</code> ）绑定</p>
<h4 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2. 执行阶段"></a>2. 执行阶段</h4><p>​    在这阶段，执行变量赋值、代码执行</p>
<p>​    如果 <code>Javascript</code> 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 <code>undefined</code> 值。</p>
<h4 id="3-回收阶段"><a href="#3-回收阶段" class="headerlink" title="3. 回收阶段"></a>3. 回收阶段</h4><p>​    执行上下文出栈等待虚拟机回收执行上下文。</p>
<h3 id="三、执行栈"><a href="#三、执行栈" class="headerlink" title="三、执行栈"></a>三、执行栈</h3><p>​    执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。</p>
<p>​    当<code>Javascript</code>引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中。</p>
<p>​    每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中。</p>
<p>​    引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文。</p>
<p>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/09/javascript%E7%B3%BB%E5%88%97-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-js/" data-id="ckpotsfbg0000gkvm6xwi44i5" data-title="javascript系列-执行上下文和执行栈.js" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascipt系列-this对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/07/javascipt%E7%B3%BB%E5%88%97-this%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2021-06-07T00:36:12.000Z" itemprop="datePublished">2021-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/07/javascipt%E7%B3%BB%E5%88%97-this%E5%AF%B9%E8%B1%A1/">javascipt系列-this对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>​    在标准函数中，this引用的是把函数当成方法调用的上下文对象，这时候通常称其为this值（在网页的全局上下文中调用函数时，this指向window对象）</p>
<p>​    this关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// this在函数执行过程中，一旦被确定，就不能再修改了</span><br><span class="line">var a = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  this = obj;               // 修改this运行会报错</span><br><span class="line">  console.log(this.a);      // SyntaxError: Invalid left-hand side in assignment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<h3 id="二、绑定规则"><a href="#二、绑定规则" class="headerlink" title="二、绑定规则"></a>二、绑定规则</h3><h4 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;mc&#x27;;</span><br><span class="line">function person() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line">console.log(person());  // mc</span><br></pre></td></tr></table></figure>

<p>this指向window，所以输出结果是mc；</p>
<!--注意：严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数在非严格模式下运行，默认绑定才能绑定到全局对象。-->

<h4 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h4><p>​    函数可以作为某个对象的方法调用，this指向上一级的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">  console.log(this.x);      // 1</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.x = 1;</span><br><span class="line">obj.test = test;</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure>

<p>​    以下这个函数包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它的上一级对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  b: &#123;</span><br><span class="line">    fn: function() &#123;</span><br><span class="line">      console.log(this.a);	// undefined</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn();     </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  b: &#123;</span><br><span class="line">    a: 12,</span><br><span class="line">    fn: function() &#123;</span><br><span class="line">      console.log(this.a);      // undefined</span><br><span class="line">      console.log(this);        // window</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var j = o.b.fn;</span><br><span class="line">j();</span><br></pre></td></tr></table></figure>

<p>此时<code>this</code>指向的是<code>window</code>，这里的大家需要记住，<code>this</code>永远指向的是最后调用它的对象，虽然<code>fn</code>是对象<code>b</code>的方法，但是<code>fn</code>赋值给<code>j</code>时候并没有执行，所以最终指向<code>window</code>。</p>
<h4 id="3-new绑定"><a href="#3-new绑定" class="headerlink" title="3. new绑定"></a>3. new绑定</h4><p>​    通过构建函数<code>new</code>关键字生成一个实例对象，此时this指向这个实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Test() &#123;</span><br><span class="line">  this.x = 1;</span><br><span class="line">&#125;</span><br><span class="line">var obj = new Test();</span><br><span class="line">console.log(obj.x);   // 1</span><br></pre></td></tr></table></figure>

<p>​    <code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象。返回的是基本数据类型或者<code>null</code>，this仍指向实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fn() &#123;</span><br><span class="line">  this.x = 1;</span><br><span class="line">  // return &#123;&#125;;</span><br><span class="line">  // return 1;</span><br><span class="line">  return null</span><br><span class="line">&#125;</span><br><span class="line">var a = new Fn();</span><br><span class="line">console.log(a.x);   // undefined  1  1 </span><br></pre></td></tr></table></figure>

<h4 id="4-显式修改"><a href="#4-显式修改" class="headerlink" title="4. 显式修改"></a>4. 显式修改</h4><p>​    <code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">function Test() &#123;</span><br><span class="line"> console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.x = 1;</span><br><span class="line">obj.m = Test;</span><br><span class="line">obj.m();   // 1</span><br><span class="line">obj.m.call(obj);   // 1</span><br></pre></td></tr></table></figure>

<h3 id="三、箭头函数"><a href="#三、箭头函数" class="headerlink" title="三、箭头函数"></a>三、箭头函数</h3><p>​    原型上添加方法时候，<code>this</code>指向<code>window</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Cat() &#123;&#125;</span><br><span class="line">Cat.prototype.sayHello = () =&gt; &#123;</span><br><span class="line">  console.log(this === window);  // true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const cat = new Cat();</span><br><span class="line">cat.sayHello();</span><br></pre></td></tr></table></figure>

<h3 id="四、优先级"><a href="#四、优先级" class="headerlink" title="四、优先级"></a>四、优先级</h3><p>​    new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/07/javascipt%E7%B3%BB%E5%88%97-this%E5%AF%B9%E8%B1%A1/" data-id="ckpmc5ce60000w4vm6g12e7r8" data-title="javascipt系列-this对象" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-继承" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/04/javascript%E7%B3%BB%E5%88%97-%E7%BB%A7%E6%89%BF/" class="article-date">
  <time class="dt-published" datetime="2021-06-04T05:13:37.000Z" itemprop="datePublished">2021-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/04/javascript%E7%B3%BB%E5%88%97-%E7%BB%A7%E6%89%BF/">javascript系列-继承</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类具有父类各种属性和方法。</p>
<h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><ul>
<li>原型中引用值会在所有实例中共享，这也是为什么会在构造函数中定义而不在原型上的原因。</li>
<li>子类型在实例化时不能给父类型构造函数传参</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">  this.colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType() &#123;&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">const instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&#x27;black&#x27;);</span><br><span class="line">console.log(instance1.colors);          // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ]</span><br><span class="line">const instance2 = new SubType();</span><br><span class="line">console.log(instance2.colors);          // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ]</span><br></pre></td></tr></table></figure>

<h4 id="2-盗用构造函数继承（对象伪装或者经典继承）"><a href="#2-盗用构造函数继承（对象伪装或者经典继承）" class="headerlink" title="2. 盗用构造函数继承（对象伪装或者经典继承）"></a>2. 盗用构造函数继承（对象伪装或者经典继承）</h4><ul>
<li>核心思想: 子类构造函数调用父类构造函数</li>
<li>原因: 函数是在特定上下文中执行代码的简单对象，可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。</li>
<li>优点: 可以在子类构造函数中向父类构造函数传参</li>
<li>缺点：必须在构造函数中定义方法，函数不能重用；子类也不能访问父类原型上的方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function superType(name) &#123;</span><br><span class="line">  this.colors = [&#x27;red&#x27;, &#x27;green&#x27;];</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">superType.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(`This is $&#123;this.name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subType() &#123;</span><br><span class="line">  superType.call(this, &#x27;mc&#x27;);</span><br><span class="line">  this.age = 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance1 = new subType();      </span><br><span class="line">instance1.colors.push(&#x27;black&#x27;);</span><br><span class="line">const instance2 = new subType();</span><br><span class="line">console.log(instance1.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="line">console.log(instance2.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27; ]</span><br><span class="line">console.log(instance1.name, instance1.age);   // mc 18</span><br><span class="line">console.log(instance1.sayName());             // TypeError: instance1.sayName is not a function</span><br></pre></td></tr></table></figure>

<h4 id="3-组合继承（伪经典继承）"><a href="#3-组合继承（伪经典继承）" class="headerlink" title="3. 组合继承（伪经典继承）"></a>3. 组合继承（伪经典继承）</h4><ul>
<li>描述：综合了盗用构造函数和原型链</li>
<li>思路：通过原型链来继承原型上的属性和方法，通过盗用构造函数来继承实例属性</li>
<li>组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function superType(name) &#123;</span><br><span class="line">  this.colors = [&#x27;red&#x27;, &#x27;green&#x27;];</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">superType.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(`This is $&#123;this.name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subType() &#123;</span><br><span class="line">  // 继承属性</span><br><span class="line">  superType.call(this, &#x27;mc&#x27;);</span><br><span class="line">  this.age = 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承方法</span><br><span class="line">subType.prototype = new superType();</span><br><span class="line">subType.prototype.sayHello = function() &#123;</span><br><span class="line">  console.log(`Hello~`);</span><br><span class="line">&#125;</span><br><span class="line">const instance1 = new subType();      </span><br><span class="line">instance1.colors.push(&#x27;black&#x27;);</span><br><span class="line">const instance2 = new subType();</span><br><span class="line">console.log(instance1.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="line">console.log(instance2.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27; ]</span><br><span class="line">console.log(instance1.name, instance1.age);   // mc 18</span><br><span class="line">console.log(instance1.sayName());             // This is mc</span><br><span class="line">console.log(instance2.sayHello());            // Hello</span><br><span class="line">console.log(instance1 instanceof superType);  // true</span><br><span class="line">console.log(superType.prototype.isPrototypeOf(instance2));    // true</span><br></pre></td></tr></table></figure>

<h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h4><ul>
<li>定义：即使不定义类型也可以通过原型实现对象之间的信息共享创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上是对传入对象实现了一次浅复制。</li>
<li>使用场景：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123; &#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person = &#123;</span><br><span class="line">  name: &quot;Nicholas&quot;,</span><br><span class="line">  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">let anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">let yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line">console.log(person.friends);            // [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="line">console.log(anotherPerson.friends);     // [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="line">const instance1 = Object.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: &#x27;Gery&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(instance1.friends, instance1.name);         // [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ] Gery</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h4><ul>
<li>思路：类似于寄生构造函数和工厂模式，创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</li>
<li>注意：通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original) &#123;</span><br><span class="line">  let clone = object(original);</span><br><span class="line">  clone.sayHi = () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Hi~&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;mc&#x27;</span><br><span class="line">&#125;</span><br><span class="line">let anotherPerson = createAnother(person);</span><br><span class="line">console.log(anotherPerson.sayHi());     // Hi</span><br></pre></td></tr></table></figure>

<h4 id="6-寄生式组合继承"><a href="#6-寄生式组合继承" class="headerlink" title="6. 寄生式组合继承"></a>6. 寄生式组合继承</h4><ul>
<li>组合继承会两次调用父类构造函数，一次是创建子类原型时调用的，一类是子类构造函数中调用的。</li>
<li>思路：不通过调用父类构造函数给子类原型赋值，而是取用父类原型上的一个副本，使用寄生式继承来继承父类原型，将返回的新对象赋值给子类原型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123;&#125;;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">  let prototype = object(superType.prototype);    // 创建对象</span><br><span class="line">  // let prototype = Object.create(superType.prototype);</span><br><span class="line">  prototype.constructor = subType;                // 增强对象</span><br><span class="line">  subType.prototype = prototype;                  // 赋值对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function superType(name) &#123;</span><br><span class="line">  this.colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">superType.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(`This is $&#123;this.name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subType() &#123;</span><br><span class="line">  superType.call(this, &#x27;mc&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(subType, superType);</span><br><span class="line"></span><br><span class="line">const instance1 = new subType();      </span><br><span class="line">instance1.colors.push(&#x27;black&#x27;);</span><br><span class="line">const instance2 = new subType();</span><br><span class="line">console.log(instance1.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="line">console.log(instance2.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27; ]</span><br><span class="line">console.log(instance1.name);                  // mc </span><br><span class="line">console.log(instance1.sayName());             // This is mc</span><br><span class="line">console.log(instance1 instanceof superType);  // true</span><br><span class="line">console.log(superType.prototype.isPrototypeOf(instance2));    // true</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/04/javascript%E7%B3%BB%E5%88%97-%E7%BB%A7%E6%89%BF/" data-id="ckphynxzg0000agvm9lgy2xxu" data-title="javascript系列-继承" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-原型和原型链" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/03/javascript%E7%B3%BB%E5%88%97-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="article-date">
  <time class="dt-published" datetime="2021-06-03T00:26:03.000Z" itemprop="datePublished">2021-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/03/javascript%E7%B3%BB%E5%88%97-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/">javascript系列-原型和原型链</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、原型"><a href="#一、原型" class="headerlink" title="一、原型"></a>一、原型</h3><p>​    每个对象都会有一个原型对象。每个函数也可以有特殊属性叫原型prototype。</p>
<p>​    原型对象上有个属性叫constructor，它指向这个函数。</p>
<h3 id="二、原型链"><a href="#二、原型链" class="headerlink" title="二、原型链"></a>二、原型链</h3><p>​    原型对象也可以有原型，并从中继承方法和属性，一层一层，以此类推。这种关系被称为原型链，它解释了一个对象为何会拥有其他对象的属性和方法。</p>
<p>​    在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的<code>prototype</code>属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.sayName = function() &#123;</span><br><span class="line">    console.log(`This is $&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;mc&#x27;);</span><br><span class="line">console.log(person1.__proto__ === Person.prototype);              // true</span><br><span class="line">console.log(Person.prototype.__proto__ === Object.prototype);     // true</span><br><span class="line">console.log(Object.prototype.__proto__ === null);                 // true</span><br><span class="line">console.log(Object.__proto__ === Function.prototype);             // true</span><br></pre></td></tr></table></figure>

<p><img src="E:\桌面项目\前端学习\面试题\画图\原型链.png" alt="原型链"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/03/javascript%E7%B3%BB%E5%88%97-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" data-id="ckpgflp7k00002cvmcb1i2asa" data-title="javascript系列-原型和原型链" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-作用域" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="article-date">
  <time class="dt-published" datetime="2021-06-02T02:30:19.000Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E4%BD%9C%E7%94%A8%E5%9F%9F/">javascript系列-作用域</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p>​    作用域，即变量（变量作用域又称执行上下文）和函数生效（能被访问）的区域或集合。</p>
<p>​    作用域决定了代码区块中变量和其他资源可见性。</p>
<h3 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h3><h4 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1. 全局作用域"></a>1. 全局作用域</h4><p>​    任何不在函数中或是大括号内声明的变量，都是在全局作用域中，全局作用域下声明的变量会在程序的任何地方可以访问到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const greeting = &#x27;Hello World&#x27;;</span><br><span class="line">function greet() &#123;</span><br><span class="line">  console.log(greeting);    // Hello World</span><br><span class="line">&#125;</span><br><span class="line">greet();</span><br></pre></td></tr></table></figure>

<h4 id="2-函数作用域"><a href="#2-函数作用域" class="headerlink" title="2. 函数作用域"></a>2. 函数作用域</h4><p>​    函数作用域也称局部作用域，如果一个变量是在函数内部中声明的，它就在一个函数作用域下面。这些变量只能在函数内部中访问，而不能在函数外部中访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function greet() &#123;</span><br><span class="line">  const greeting = &#x27;Hello World&#x27;;</span><br><span class="line">  console.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line">greet();                    // Hello World</span><br><span class="line">console.log(greeting);      // ReferenceError: greeting is not defined</span><br></pre></td></tr></table></figure>

<h4 id="3-块级作用域"><a href="#3-块级作用域" class="headerlink" title="3. 块级作用域"></a>3. 块级作用域</h4><p>​    let和const定义的变量，只能在大括号中使用，外部访问不到变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let greeting = &#x27;Hello World&#x27;;</span><br><span class="line">  var lang = &#x27;English&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(lang);        // English</span><br><span class="line">console.log(greeting);    // ReferenceError: greeting is not defined</span><br></pre></td></tr></table></figure>

<h3 id="三、词法作用域"><a href="#三、词法作用域" class="headerlink" title="三、词法作用域"></a>三、词法作用域</h3><p>​    词法作用域又叫静态作用域，变量被创建时就确定好了，而非执行阶段创建的。也就是说我们写好代码时它的作用域就确定了，<code>JavaScript</code> 遵循的就是词法作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(a);     // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">  var a = 3;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>​    由于<code>JavaScript</code>遵循词法作用域，相同层级的 <code>foo</code> 和 <code>bar</code> 就没有办法访问到彼此块作用域中的变量，所以输出2。</p>
<h3 id="四、作用域链"><a href="#四、作用域链" class="headerlink" title="四、作用域链"></a>四、作用域链</h3><p>​    当在javascript中使用一个变量的时候，首先javascript引擎会尝试在当前作用域下寻找该变量，若未找到再到上一层作用域中去寻找，以此类推直到找到该变量或是已经到了全局作用域。</p>
<p>​    如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var sex = &#x27;男&#x27;;</span><br><span class="line">function person() &#123;</span><br><span class="line">    var name = &#x27;张三&#x27;;</span><br><span class="line">    function student() &#123;</span><br><span class="line">        var age = 18;</span><br><span class="line">        console.log(name); // 张三</span><br><span class="line">        console.log(sex); // 男 </span><br><span class="line">    &#125;</span><br><span class="line">    student();</span><br><span class="line">    console.log(age); // Uncaught ReferenceError: age is not defined</span><br><span class="line">&#125;</span><br><span class="line">person();</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E4%BD%9C%E7%94%A8%E5%9F%9F/" data-id="ckpew97eo00007wvm46zz7doy" data-title="javascript系列-作用域" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-闭包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E9%97%AD%E5%8C%85/" class="article-date">
  <time class="dt-published" datetime="2021-06-02T00:31:03.000Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E9%97%AD%E5%8C%85/">javascript系列-闭包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、闭包是什么？"><a href="#一、闭包是什么？" class="headerlink" title="一、闭包是什么？"></a>一、闭包是什么？</h3><p>​    闭包指的是<strong>那些引用了另一个函数作用域中变量的函数</strong>，通常是在嵌套函数中使用。</p>
<p>​    闭包可以让在内部函数中访问外部函数作用域。</p>
<p>​    函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫<code>变量对象</code>，它会在代码执行期间始终存在。而函数局部上下文中的叫<code>活动对象</code>，只会在函数执行期间存在。</p>
<p>​    在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域中。</p>
<p>​    每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永远不可能直接访问外部函数的这两个变量。</p>
<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>​    任何闭包的使用场景都离不开以下两点：</p>
<ul>
<li>创建私有变量</li>
<li>延长变量的生命周期</li>
</ul>
<h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function init() &#123;</span><br><span class="line">  var name = &#x27;mc&#x27;;</span><br><span class="line">  function displayName() &#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  displayName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br></pre></td></tr></table></figure>

<h4 id="2-在页面上添加一些可以调整字号的按钮"><a href="#2-在页面上添加一些可以调整字号的按钮" class="headerlink" title="2. 在页面上添加一些可以调整字号的按钮"></a>2. 在页面上添加一些可以调整字号的按钮</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function makeSizer(size) &#123;</span><br><span class="line">      return function() &#123;</span><br><span class="line">        document.body.style.fontSize = size + &#x27;px&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">const size1 = makeSizer(12);</span><br><span class="line">const size2 = makeSizer(14);</span><br><span class="line">const size3 = makeSizer(16);</span><br><span class="line"></span><br><span class="line">document.querySelector(&#x27;.demo1&#x27;).onclick = size1;</span><br><span class="line">document.querySelector(&#x27;.demo2&#x27;).onclick = size2;</span><br><span class="line">document.querySelector(&#x27;.demo3&#x27;).onclick = size3;</span><br></pre></td></tr></table></figure>

<h4 id="3-柯里化函数"><a href="#3-柯里化函数" class="headerlink" title="3. 柯里化函数"></a>3. 柯里化函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getArea(width) &#123;</span><br><span class="line">  return height =&gt; width * height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getTenWidth = getArea(10);</span><br><span class="line">console.log(getTenWidth(20));   // 200</span><br><span class="line">console.log(getTenWidth(30));   // 300</span><br></pre></td></tr></table></figure>

<h3 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h3><p>​    过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。创建的函数被保存在变量中。把变量设置为等于 null 会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。</p>
<p>​    例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。</p>
<p>​    原因在于每个对象的创建，方法都会被重新赋值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E9%97%AD%E5%8C%85/" data-id="ckpeujnzy0000ycvm95qofk3p" data-title="javascript系列-闭包" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-浅拷贝和深拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2021-06-01T05:21:02.000Z" itemprop="datePublished">2021-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/">javascript系列-浅拷贝和深拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、数据类型存储"><a href="#一、数据类型存储" class="headerlink" title="一、数据类型存储"></a>一、数据类型存储</h3><p>javascript存在两大数据类型：</p>
<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
<p>基本数据类型保存在栈内存中。</p>
<p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中。（堆允许程序在运行时动态申请某个大小的内存空间）</p>
<h3 id="二、浅拷贝"><a href="#二、浅拷贝" class="headerlink" title="二、浅拷贝"></a>二、浅拷贝</h3><p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝。</p>
<p>如果属性是基本类型数据，则拷贝的是数据的值；如果属性值是引用数据类型，则拷贝的是内存地址。</p>
<p>浅拷贝拷贝一层，深层次的引用类型则共享内存地址。</p>
<p>下面简单实现一个浅拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function shallowClone(obj) &#123;</span><br><span class="line">  const newObj = &#123;&#125;;</span><br><span class="line">  for(let prop in obj) &#123;</span><br><span class="line">    if(obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">      newObj[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(shallowClone(&#123;a: 1, b: 2&#125;));    // &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure>

<p>在javascript中存在的浅拷贝现象有：</p>
<ul>
<li>Object.assign()</li>
<li>Array.prototype.slice()，Array.prototype.concat()</li>
<li>使用扩展运算符实现的复制</li>
</ul>
<h4 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1. Object.assign()"></a>1. Object.assign()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const newObj = Object.assign(&#123;&#125;, obj);</span><br><span class="line">newObj.a = 3;</span><br><span class="line">newObj.c[0] = 3;</span><br><span class="line">newObj.d.e = 3;</span><br><span class="line">console.log(obj);               // &#123; a: 1, b: &#x27;fff&#x27;, c: [ 3, 2, 3 ], d: &#123; e: 3 &#125; &#125;</span><br><span class="line">console.log(newObj);            // &#123; a: 3, b: &#x27;fff&#x27;, c: [ 3, 2, 3 ], d: &#123; e: 3 &#125; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-slice"><a href="#2-slice" class="headerlink" title="2. slice()"></a>2. slice()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const newArr = arr.slice(0);</span><br><span class="line">newArr[0] = &#x27;Y&#x27;;</span><br><span class="line">newArr[3].brother = &#x27;mc&#x27;;</span><br><span class="line">console.log(arr);                 // [ &#x27;I&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br><span class="line">console.log(newArr);              // [ &#x27;Y&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br></pre></td></tr></table></figure>

<h4 id="3-concat"><a href="#3-concat" class="headerlink" title="3. concat()"></a>3. concat()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const newArr = arr.concat();</span><br><span class="line">newArr[0] = &#x27;Y&#x27;;</span><br><span class="line">newArr[3].brother = &#x27;mc&#x27;;</span><br><span class="line">console.log(arr);                 // [ &#x27;I&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br><span class="line">console.log(newArr);              // [ &#x27;Y&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br></pre></td></tr></table></figure>

<h4 id="4-扩展运算符"><a href="#4-扩展运算符" class="headerlink" title="4. 扩展运算符"></a>4. 扩展运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const newArr = [...arr];</span><br><span class="line">newArr[0] = &#x27;Y&#x27;;</span><br><span class="line">newArr[3].brother = &#x27;mc&#x27;;</span><br><span class="line">console.log(arr);                 // [ &#x27;I&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br><span class="line">console.log(newArr);              // [ &#x27;Y&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br></pre></td></tr></table></figure>

<h3 id="三、深拷贝"><a href="#三、深拷贝" class="headerlink" title="三、深拷贝"></a>三、深拷贝</h3><p>深拷贝开辟一个新的栈，两个对象的属性完全相同，但是对应两个不同的地址，修改一个对象的属性不会改变另一个对象的属性。</p>
<h4 id="1-JSON-stringify"><a href="#1-JSON-stringify" class="headerlink" title="1. JSON.stringify()"></a>1. JSON.stringify()</h4><p>[^弊端：会忽略undefined, Symbol, function]: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const newObj = JSON.parse(JSON.stringify(obj));</span><br><span class="line">newObj.a = 3;</span><br><span class="line">newObj.c[0] = 3;</span><br><span class="line">newObj.d.e = 3;</span><br><span class="line">console.log(obj);               // &#123; a: 1, b: &#x27;fff&#x27;, c: [ 1, 2, 3 ], d: &#123; e: 33 &#125;, l: undefined, j: Symbol(&#x27;A‘), k: [Function: k] &#125;</span><br><span class="line">console.log(newObj);            // &#123; a: 3, b: &#x27;fff&#x27;, c: [ 3, 2, 3 ], d: &#123; e: 3 &#125; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-手写循环递归"><a href="#2-手写循环递归" class="headerlink" title="2. 手写循环递归"></a>2. 手写循环递归</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj, hash = new WeakMap()) &#123;</span><br><span class="line">  if(obj === null) return null;</span><br><span class="line">  if(obj instanceof Date) return new Date(obj);</span><br><span class="line">  if(obj instanceof RegExp) return new RegExp(obj);</span><br><span class="line"></span><br><span class="line">  // 基本数据类型，直接返回</span><br><span class="line">  if(typeof obj !== &#x27;object&#x27;) return obj;</span><br><span class="line"></span><br><span class="line">  // 是对象的话就进行深拷贝</span><br><span class="line">  if(hash.get(obj)) return hash.get(obj);</span><br><span class="line">  console.log(hash.get(obj));</span><br><span class="line">  let cloneObj = new obj.constructor();</span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  </span><br><span class="line">  for(let prop in obj) &#123;</span><br><span class="line">    if(obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">      // 递归</span><br><span class="line">      cloneObj[prop] = deepClone(obj[prop], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/" data-id="ckpdlabgn0000y0vmc0di4k27" data-title="javascript系列-浅拷贝和深拷贝" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-等于操作符和全等操作符的区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E7%AD%89%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%85%A8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2021-06-01T00:39:29.000Z" itemprop="datePublished">2021-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E7%AD%89%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%85%A8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/">==和===的区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="和-的区别"><a href="#和-的区别" class="headerlink" title="==和===的区别"></a>==和===的区别</h1><h2 id="一、等于操作符"><a href="#一、等于操作符" class="headerlink" title="一、等于操作符"></a>一、等于操作符</h2><p>[^javascript中存在隐式转换，等于操作符会在比较中先进行类型转换，再确定操作数是否相等。]: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1. 如果任一操作数是布尔值，会先转为数值进行比较</span><br><span class="line">console.log(true == 1);       // true</span><br><span class="line"></span><br><span class="line">// 2. 如果任一操作数是字符串，另一操作数是数值，会将字符串转为数值，再进行比较</span><br><span class="line">console.log(&#x27;55&#x27; === 55);     // false</span><br><span class="line"></span><br><span class="line">// 3. 如果一个操作数是对象，则会调用其valueOf()取得其原始值，再比较</span><br><span class="line">console.log(&#123;valueOf() &#123;return 1&#125;&#125; == 1);   // true</span><br><span class="line"></span><br><span class="line">// 4. null和undefined相等</span><br><span class="line">console.log(null == undefined);     // true</span><br><span class="line"></span><br><span class="line">// 5. 如果任一操作数是NaN，相等操作符都会返回false</span><br><span class="line">console.log(NaN == NaN);           // false</span><br><span class="line"></span><br><span class="line">// 6. 两个操作数都是对象，则判断是不是同一对象</span><br><span class="line">console.log(&#123;&#125; == &#123;&#125;);             // false</span><br><span class="line">console.log([] == []);             // false</span><br></pre></td></tr></table></figure>

<h2 id="二、全等操作符"><a href="#二、全等操作符" class="headerlink" title="二、全等操作符"></a>二、全等操作符</h2><p>[^类型相等，值也相等。]: </p>
<h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><ol>
<li>相等运算符会做类型转换在进行比较，全等运算符直接比较。</li>
<li>相等运算符undefined和null相等。</li>
<li>除了比较null和undefined使用相等运算符，其余全使用全等运算符。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E7%AD%89%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%85%A8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="ckpdder2d00000gvmae58guio" data-title="==和===的区别" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/11/javascript%E7%B3%BB%E5%88%97-typeof%E5%92%8Cinstanceof/">javascript系列-typeof和instanceof</a>
          </li>
        
          <li>
            <a href="/2021/06/10/javascript%E7%B3%BB%E5%88%97-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/">javascript系列-事件模型</a>
          </li>
        
          <li>
            <a href="/2021/06/09/javascript%E7%B3%BB%E5%88%97-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-js/">javascript系列-执行上下文和执行栈.js</a>
          </li>
        
          <li>
            <a href="/2021/06/07/javascipt%E7%B3%BB%E5%88%97-this%E5%AF%B9%E8%B1%A1/">javascipt系列-this对象</a>
          </li>
        
          <li>
            <a href="/2021/06/04/javascript%E7%B3%BB%E5%88%97-%E7%BB%A7%E6%89%BF/">javascript系列-继承</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>