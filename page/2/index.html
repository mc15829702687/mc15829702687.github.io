<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-javascript系列-继承" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/04/javascript%E7%B3%BB%E5%88%97-%E7%BB%A7%E6%89%BF/" class="article-date">
  <time class="dt-published" datetime="2021-06-04T05:13:37.000Z" itemprop="datePublished">2021-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/04/javascript%E7%B3%BB%E5%88%97-%E7%BB%A7%E6%89%BF/">javascript系列-继承</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类具有父类各种属性和方法。</p>
<h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><ul>
<li>原型中引用值会在所有实例中共享，这也是为什么会在构造函数中定义而不在原型上的原因。</li>
<li>子类型在实例化时不能给父类型构造函数传参</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">  this.colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType() &#123;&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">const instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&#x27;black&#x27;);</span><br><span class="line">console.log(instance1.colors);          // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ]</span><br><span class="line">const instance2 = new SubType();</span><br><span class="line">console.log(instance2.colors);          // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ]</span><br></pre></td></tr></table></figure>

<h4 id="2-盗用构造函数继承（对象伪装或者经典继承）"><a href="#2-盗用构造函数继承（对象伪装或者经典继承）" class="headerlink" title="2. 盗用构造函数继承（对象伪装或者经典继承）"></a>2. 盗用构造函数继承（对象伪装或者经典继承）</h4><ul>
<li>核心思想: 子类构造函数调用父类构造函数</li>
<li>原因: 函数是在特定上下文中执行代码的简单对象，可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。</li>
<li>优点: 可以在子类构造函数中向父类构造函数传参</li>
<li>缺点：必须在构造函数中定义方法，函数不能重用；子类也不能访问父类原型上的方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function superType(name) &#123;</span><br><span class="line">  this.colors = [&#x27;red&#x27;, &#x27;green&#x27;];</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">superType.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(`This is $&#123;this.name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subType() &#123;</span><br><span class="line">  superType.call(this, &#x27;mc&#x27;);</span><br><span class="line">  this.age = 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance1 = new subType();      </span><br><span class="line">instance1.colors.push(&#x27;black&#x27;);</span><br><span class="line">const instance2 = new subType();</span><br><span class="line">console.log(instance1.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="line">console.log(instance2.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27; ]</span><br><span class="line">console.log(instance1.name, instance1.age);   // mc 18</span><br><span class="line">console.log(instance1.sayName());             // TypeError: instance1.sayName is not a function</span><br></pre></td></tr></table></figure>

<h4 id="3-组合继承（伪经典继承）"><a href="#3-组合继承（伪经典继承）" class="headerlink" title="3. 组合继承（伪经典继承）"></a>3. 组合继承（伪经典继承）</h4><ul>
<li>描述：综合了盗用构造函数和原型链</li>
<li>思路：通过原型链来继承原型上的属性和方法，通过盗用构造函数来继承实例属性</li>
<li>组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function superType(name) &#123;</span><br><span class="line">  this.colors = [&#x27;red&#x27;, &#x27;green&#x27;];</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">superType.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(`This is $&#123;this.name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subType() &#123;</span><br><span class="line">  // 继承属性</span><br><span class="line">  superType.call(this, &#x27;mc&#x27;);</span><br><span class="line">  this.age = 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承方法</span><br><span class="line">subType.prototype = new superType();</span><br><span class="line">subType.prototype.sayHello = function() &#123;</span><br><span class="line">  console.log(`Hello~`);</span><br><span class="line">&#125;</span><br><span class="line">const instance1 = new subType();      </span><br><span class="line">instance1.colors.push(&#x27;black&#x27;);</span><br><span class="line">const instance2 = new subType();</span><br><span class="line">console.log(instance1.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="line">console.log(instance2.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27; ]</span><br><span class="line">console.log(instance1.name, instance1.age);   // mc 18</span><br><span class="line">console.log(instance1.sayName());             // This is mc</span><br><span class="line">console.log(instance2.sayHello());            // Hello</span><br><span class="line">console.log(instance1 instanceof superType);  // true</span><br><span class="line">console.log(superType.prototype.isPrototypeOf(instance2));    // true</span><br></pre></td></tr></table></figure>

<h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h4><ul>
<li>定义：即使不定义类型也可以通过原型实现对象之间的信息共享创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上是对传入对象实现了一次浅复制。</li>
<li>使用场景：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123; &#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person = &#123;</span><br><span class="line">  name: &quot;Nicholas&quot;,</span><br><span class="line">  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">let anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">let yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line">console.log(person.friends);            // [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="line">console.log(anotherPerson.friends);     // [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="line">const instance1 = Object.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: &#x27;Gery&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(instance1.friends, instance1.name);         // [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ] Gery</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h4><ul>
<li>思路：类似于寄生构造函数和工厂模式，创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</li>
<li>注意：通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original) &#123;</span><br><span class="line">  let clone = object(original);</span><br><span class="line">  clone.sayHi = () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Hi~&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;mc&#x27;</span><br><span class="line">&#125;</span><br><span class="line">let anotherPerson = createAnother(person);</span><br><span class="line">console.log(anotherPerson.sayHi());     // Hi</span><br></pre></td></tr></table></figure>

<h4 id="6-寄生式组合继承"><a href="#6-寄生式组合继承" class="headerlink" title="6. 寄生式组合继承"></a>6. 寄生式组合继承</h4><ul>
<li>组合继承会两次调用父类构造函数，一次是创建子类原型时调用的，一类是子类构造函数中调用的。</li>
<li>思路：不通过调用父类构造函数给子类原型赋值，而是取用父类原型上的一个副本，使用寄生式继承来继承父类原型，将返回的新对象赋值给子类原型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123;&#125;;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">  let prototype = object(superType.prototype);    // 创建对象</span><br><span class="line">  // let prototype = Object.create(superType.prototype);</span><br><span class="line">  prototype.constructor = subType;                // 增强对象</span><br><span class="line">  subType.prototype = prototype;                  // 赋值对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function superType(name) &#123;</span><br><span class="line">  this.colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">superType.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(`This is $&#123;this.name&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subType() &#123;</span><br><span class="line">  superType.call(this, &#x27;mc&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(subType, superType);</span><br><span class="line"></span><br><span class="line">const instance1 = new subType();      </span><br><span class="line">instance1.colors.push(&#x27;black&#x27;);</span><br><span class="line">const instance2 = new subType();</span><br><span class="line">console.log(instance1.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="line">console.log(instance2.colors);                // [ &#x27;red&#x27;, &#x27;green&#x27; ]</span><br><span class="line">console.log(instance1.name);                  // mc </span><br><span class="line">console.log(instance1.sayName());             // This is mc</span><br><span class="line">console.log(instance1 instanceof superType);  // true</span><br><span class="line">console.log(superType.prototype.isPrototypeOf(instance2));    // true</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/04/javascript%E7%B3%BB%E5%88%97-%E7%BB%A7%E6%89%BF/" data-id="ckuxzwzs5000g50vmc1b8comh" data-title="javascript系列-继承" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-原型和原型链" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/03/javascript%E7%B3%BB%E5%88%97-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="article-date">
  <time class="dt-published" datetime="2021-06-03T00:26:03.000Z" itemprop="datePublished">2021-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/03/javascript%E7%B3%BB%E5%88%97-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/">javascript系列-原型和原型链</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、原型"><a href="#一、原型" class="headerlink" title="一、原型"></a>一、原型</h3><p>​    每个对象都会有一个原型对象。每个函数也可以有特殊属性叫原型prototype。</p>
<p>​    原型对象上有个属性叫constructor，它指向这个函数。</p>
<h3 id="二、原型链"><a href="#二、原型链" class="headerlink" title="二、原型链"></a>二、原型链</h3><p>​    原型对象也可以有原型，并从中继承方法和属性，一层一层，以此类推。这种关系被称为原型链，它解释了一个对象为何会拥有其他对象的属性和方法。</p>
<p>​    在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的<code>prototype</code>属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.sayName = function() &#123;</span><br><span class="line">    console.log(`This is $&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;mc&#x27;);</span><br><span class="line">console.log(person1.__proto__ === Person.prototype);              // true</span><br><span class="line">console.log(Person.prototype.__proto__ === Object.prototype);     // true</span><br><span class="line">console.log(Object.prototype.__proto__ === null);                 // true</span><br><span class="line">console.log(Object.__proto__ === Function.prototype);             // true</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/03/javascript%E7%B3%BB%E5%88%97-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/桌面项目\前端学习\面试题\画图\原型链.png" alt="原型链"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/03/javascript%E7%B3%BB%E5%88%97-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" data-id="ckuxzwzrr000950vm98vu4ng9" data-title="javascript系列-原型和原型链" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-作用域" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="article-date">
  <time class="dt-published" datetime="2021-06-02T02:30:19.000Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E4%BD%9C%E7%94%A8%E5%9F%9F/">javascript系列-作用域</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p>​    作用域，即变量（变量作用域又称执行上下文）和函数生效（能被访问）的区域或集合。</p>
<p>​    作用域决定了代码区块中变量和其他资源可见性。</p>
<h3 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h3><h4 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1. 全局作用域"></a>1. 全局作用域</h4><p>​    任何不在函数中或是大括号内声明的变量，都是在全局作用域中，全局作用域下声明的变量会在程序的任何地方可以访问到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const greeting = &#x27;Hello World&#x27;;</span><br><span class="line">function greet() &#123;</span><br><span class="line">  console.log(greeting);    // Hello World</span><br><span class="line">&#125;</span><br><span class="line">greet();</span><br></pre></td></tr></table></figure>

<h4 id="2-函数作用域"><a href="#2-函数作用域" class="headerlink" title="2. 函数作用域"></a>2. 函数作用域</h4><p>​    函数作用域也称局部作用域，如果一个变量是在函数内部中声明的，它就在一个函数作用域下面。这些变量只能在函数内部中访问，而不能在函数外部中访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function greet() &#123;</span><br><span class="line">  const greeting = &#x27;Hello World&#x27;;</span><br><span class="line">  console.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line">greet();                    // Hello World</span><br><span class="line">console.log(greeting);      // ReferenceError: greeting is not defined</span><br></pre></td></tr></table></figure>

<h4 id="3-块级作用域"><a href="#3-块级作用域" class="headerlink" title="3. 块级作用域"></a>3. 块级作用域</h4><p>​    let和const定义的变量，只能在大括号中使用，外部访问不到变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let greeting = &#x27;Hello World&#x27;;</span><br><span class="line">  var lang = &#x27;English&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(lang);        // English</span><br><span class="line">console.log(greeting);    // ReferenceError: greeting is not defined</span><br></pre></td></tr></table></figure>

<h3 id="三、词法作用域"><a href="#三、词法作用域" class="headerlink" title="三、词法作用域"></a>三、词法作用域</h3><p>​    词法作用域又叫静态作用域，变量被创建时就确定好了，而非执行阶段创建的。也就是说我们写好代码时它的作用域就确定了，<code>JavaScript</code> 遵循的就是词法作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(a);     // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">  var a = 3;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>​    由于<code>JavaScript</code>遵循词法作用域，相同层级的 <code>foo</code> 和 <code>bar</code> 就没有办法访问到彼此块作用域中的变量，所以输出2。</p>
<h3 id="四、作用域链"><a href="#四、作用域链" class="headerlink" title="四、作用域链"></a>四、作用域链</h3><p>​    当在javascript中使用一个变量的时候，首先javascript引擎会尝试在当前作用域下寻找该变量，若未找到再到上一层作用域中去寻找，以此类推直到找到该变量或是已经到了全局作用域。</p>
<p>​    如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var sex = &#x27;男&#x27;;</span><br><span class="line">function person() &#123;</span><br><span class="line">    var name = &#x27;张三&#x27;;</span><br><span class="line">    function student() &#123;</span><br><span class="line">        var age = 18;</span><br><span class="line">        console.log(name); // 张三</span><br><span class="line">        console.log(sex); // 男 </span><br><span class="line">    &#125;</span><br><span class="line">    student();</span><br><span class="line">    console.log(age); // Uncaught ReferenceError: age is not defined</span><br><span class="line">&#125;</span><br><span class="line">person();</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E4%BD%9C%E7%94%A8%E5%9F%9F/" data-id="ckuxzwzrp000850vm1lg8hog4" data-title="javascript系列-作用域" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-闭包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E9%97%AD%E5%8C%85/" class="article-date">
  <time class="dt-published" datetime="2021-06-02T00:31:03.000Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E9%97%AD%E5%8C%85/">javascript系列-闭包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、闭包是什么？"><a href="#一、闭包是什么？" class="headerlink" title="一、闭包是什么？"></a>一、闭包是什么？</h3><p>​    闭包指的是<strong>那些引用了另一个函数作用域中变量的函数</strong>，通常是在嵌套函数中使用。</p>
<p>​    闭包可以让在内部函数中访问外部函数作用域。</p>
<p>​    函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫<code>变量对象</code>，它会在代码执行期间始终存在。而函数局部上下文中的叫<code>活动对象</code>，只会在函数执行期间存在。</p>
<p>​    在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域中。</p>
<p>​    每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永远不可能直接访问外部函数的这两个变量。</p>
<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>​    任何闭包的使用场景都离不开以下两点：</p>
<ul>
<li>创建私有变量</li>
<li>延长变量的生命周期</li>
</ul>
<h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function init() &#123;</span><br><span class="line">  var name = &#x27;mc&#x27;;</span><br><span class="line">  function displayName() &#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  displayName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br></pre></td></tr></table></figure>

<h4 id="2-在页面上添加一些可以调整字号的按钮"><a href="#2-在页面上添加一些可以调整字号的按钮" class="headerlink" title="2. 在页面上添加一些可以调整字号的按钮"></a>2. 在页面上添加一些可以调整字号的按钮</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function makeSizer(size) &#123;</span><br><span class="line">      return function() &#123;</span><br><span class="line">        document.body.style.fontSize = size + &#x27;px&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">const size1 = makeSizer(12);</span><br><span class="line">const size2 = makeSizer(14);</span><br><span class="line">const size3 = makeSizer(16);</span><br><span class="line"></span><br><span class="line">document.querySelector(&#x27;.demo1&#x27;).onclick = size1;</span><br><span class="line">document.querySelector(&#x27;.demo2&#x27;).onclick = size2;</span><br><span class="line">document.querySelector(&#x27;.demo3&#x27;).onclick = size3;</span><br></pre></td></tr></table></figure>

<h4 id="3-柯里化函数"><a href="#3-柯里化函数" class="headerlink" title="3. 柯里化函数"></a>3. 柯里化函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getArea(width) &#123;</span><br><span class="line">  return height =&gt; width * height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getTenWidth = getArea(10);</span><br><span class="line">console.log(getTenWidth(20));   // 200</span><br><span class="line">console.log(getTenWidth(30));   // 300</span><br></pre></td></tr></table></figure>

<h3 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h3><p>​    过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。创建的函数被保存在变量中。把变量设置为等于 null 会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。</p>
<p>​    例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。</p>
<p>​    原因在于每个对象的创建，方法都会被重新赋值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/02/javascript%E7%B3%BB%E5%88%97-%E9%97%AD%E5%8C%85/" data-id="ckuxzwzs7000h50vm2eau2atz" data-title="javascript系列-闭包" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-浅拷贝和深拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2021-06-01T05:21:02.000Z" itemprop="datePublished">2021-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/">javascript系列-浅拷贝和深拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、数据类型存储"><a href="#一、数据类型存储" class="headerlink" title="一、数据类型存储"></a>一、数据类型存储</h3><p>javascript存在两大数据类型：</p>
<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
<p>基本数据类型保存在栈内存中。</p>
<p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中。（堆允许程序在运行时动态申请某个大小的内存空间）</p>
<h3 id="二、浅拷贝"><a href="#二、浅拷贝" class="headerlink" title="二、浅拷贝"></a>二、浅拷贝</h3><p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝。</p>
<p>如果属性是基本类型数据，则拷贝的是数据的值；如果属性值是引用数据类型，则拷贝的是内存地址。</p>
<p>浅拷贝拷贝一层，深层次的引用类型则共享内存地址。</p>
<p>下面简单实现一个浅拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function shallowClone(obj) &#123;</span><br><span class="line">  const newObj = &#123;&#125;;</span><br><span class="line">  for(let prop in obj) &#123;</span><br><span class="line">    if(obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">      newObj[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(shallowClone(&#123;a: 1, b: 2&#125;));    // &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure>

<p>在javascript中存在的浅拷贝现象有：</p>
<ul>
<li>Object.assign()</li>
<li>Array.prototype.slice()，Array.prototype.concat()</li>
<li>使用扩展运算符实现的复制</li>
</ul>
<h4 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1. Object.assign()"></a>1. Object.assign()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const newObj = Object.assign(&#123;&#125;, obj);</span><br><span class="line">newObj.a = 3;</span><br><span class="line">newObj.c[0] = 3;</span><br><span class="line">newObj.d.e = 3;</span><br><span class="line">console.log(obj);               // &#123; a: 1, b: &#x27;fff&#x27;, c: [ 3, 2, 3 ], d: &#123; e: 3 &#125; &#125;</span><br><span class="line">console.log(newObj);            // &#123; a: 3, b: &#x27;fff&#x27;, c: [ 3, 2, 3 ], d: &#123; e: 3 &#125; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-slice"><a href="#2-slice" class="headerlink" title="2. slice()"></a>2. slice()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const newArr = arr.slice(0);</span><br><span class="line">newArr[0] = &#x27;Y&#x27;;</span><br><span class="line">newArr[3].brother = &#x27;mc&#x27;;</span><br><span class="line">console.log(arr);                 // [ &#x27;I&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br><span class="line">console.log(newArr);              // [ &#x27;Y&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br></pre></td></tr></table></figure>

<h4 id="3-concat"><a href="#3-concat" class="headerlink" title="3. concat()"></a>3. concat()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const newArr = arr.concat();</span><br><span class="line">newArr[0] = &#x27;Y&#x27;;</span><br><span class="line">newArr[3].brother = &#x27;mc&#x27;;</span><br><span class="line">console.log(arr);                 // [ &#x27;I&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br><span class="line">console.log(newArr);              // [ &#x27;Y&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br></pre></td></tr></table></figure>

<h4 id="4-扩展运算符"><a href="#4-扩展运算符" class="headerlink" title="4. 扩展运算符"></a>4. 扩展运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const newArr = [...arr];</span><br><span class="line">newArr[0] = &#x27;Y&#x27;;</span><br><span class="line">newArr[3].brother = &#x27;mc&#x27;;</span><br><span class="line">console.log(arr);                 // [ &#x27;I&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br><span class="line">console.log(newArr);              // [ &#x27;Y&#x27;, &#x27;Love&#x27;, &#x27;Ms.Zhang&#x27;, &#123; brother: &#x27;mc&#x27; &#125; ]</span><br></pre></td></tr></table></figure>

<h3 id="三、深拷贝"><a href="#三、深拷贝" class="headerlink" title="三、深拷贝"></a>三、深拷贝</h3><p>深拷贝开辟一个新的栈，两个对象的属性完全相同，但是对应两个不同的地址，修改一个对象的属性不会改变另一个对象的属性。</p>
<h4 id="1-JSON-stringify"><a href="#1-JSON-stringify" class="headerlink" title="1. JSON.stringify()"></a>1. JSON.stringify()</h4><p>[^弊端：会忽略undefined, Symbol, function]: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const newObj = JSON.parse(JSON.stringify(obj));</span><br><span class="line">newObj.a = 3;</span><br><span class="line">newObj.c[0] = 3;</span><br><span class="line">newObj.d.e = 3;</span><br><span class="line">console.log(obj);               // &#123; a: 1, b: &#x27;fff&#x27;, c: [ 1, 2, 3 ], d: &#123; e: 33 &#125;, l: undefined, j: Symbol(&#x27;A‘), k: [Function: k] &#125;</span><br><span class="line">console.log(newObj);            // &#123; a: 3, b: &#x27;fff&#x27;, c: [ 3, 2, 3 ], d: &#123; e: 3 &#125; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-手写循环递归"><a href="#2-手写循环递归" class="headerlink" title="2. 手写循环递归"></a>2. 手写循环递归</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj, hash = new WeakMap()) &#123;</span><br><span class="line">  if(obj === null) return null;</span><br><span class="line">  if(obj instanceof Date) return new Date(obj);</span><br><span class="line">  if(obj instanceof RegExp) return new RegExp(obj);</span><br><span class="line"></span><br><span class="line">  // 基本数据类型，直接返回</span><br><span class="line">  if(typeof obj !== &#x27;object&#x27;) return obj;</span><br><span class="line"></span><br><span class="line">  // 是对象的话就进行深拷贝</span><br><span class="line">  if(hash.get(obj)) return hash.get(obj);</span><br><span class="line">  console.log(hash.get(obj));</span><br><span class="line">  let cloneObj = new obj.constructor();</span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  </span><br><span class="line">  for(let prop in obj) &#123;</span><br><span class="line">    if(obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">      // 递归</span><br><span class="line">      cloneObj[prop] = deepClone(obj[prop], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/" data-id="ckuxzwzs0000d50vm9z1i25zr" data-title="javascript系列-浅拷贝和深拷贝" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-等于操作符和全等操作符的区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E7%AD%89%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%85%A8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2021-06-01T00:39:29.000Z" itemprop="datePublished">2021-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E7%AD%89%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%85%A8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/">==和===的区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="和-的区别"><a href="#和-的区别" class="headerlink" title="==和===的区别"></a>==和===的区别</h1><h2 id="一、等于操作符"><a href="#一、等于操作符" class="headerlink" title="一、等于操作符"></a>一、等于操作符</h2><p>[^javascript中存在隐式转换，等于操作符会在比较中先进行类型转换，再确定操作数是否相等。]: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1. 如果任一操作数是布尔值，会先转为数值进行比较</span><br><span class="line">console.log(true == 1);       // true</span><br><span class="line"></span><br><span class="line">// 2. 如果任一操作数是字符串，另一操作数是数值，会将字符串转为数值，再进行比较</span><br><span class="line">console.log(&#x27;55&#x27; === 55);     // false</span><br><span class="line"></span><br><span class="line">// 3. 如果一个操作数是对象，则会调用其valueOf()取得其原始值，再比较</span><br><span class="line">console.log(&#123;valueOf() &#123;return 1&#125;&#125; == 1);   // true</span><br><span class="line"></span><br><span class="line">// 4. null和undefined相等</span><br><span class="line">console.log(null == undefined);     // true</span><br><span class="line"></span><br><span class="line">// 5. 如果任一操作数是NaN，相等操作符都会返回false</span><br><span class="line">console.log(NaN == NaN);           // false</span><br><span class="line"></span><br><span class="line">// 6. 两个操作数都是对象，则判断是不是同一对象</span><br><span class="line">console.log(&#123;&#125; == &#123;&#125;);             // false</span><br><span class="line">console.log([] == []);             // false</span><br></pre></td></tr></table></figure>

<h2 id="二、全等操作符"><a href="#二、全等操作符" class="headerlink" title="二、全等操作符"></a>二、全等操作符</h2><p>[^类型相等，值也相等。]: </p>
<h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><ol>
<li>相等运算符会做类型转换在进行比较，全等运算符直接比较。</li>
<li>相等运算符undefined和null相等。</li>
<li>除了比较null和undefined使用相等运算符，其余全使用全等运算符。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/01/javascript%E7%B3%BB%E5%88%97-%E7%AD%89%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%85%A8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="ckuxzwzs2000e50vmh7hegot6" data-title="==和===的区别" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-类型转换机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/31/javascript%E7%B3%BB%E5%88%97-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-05-31T01:54:35.000Z" itemprop="datePublished">2021-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/31/javascript%E7%B3%BB%E5%88%97-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6/">javascript系列-类型转换机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="javascript系列-类型转换机制"><a href="#javascript系列-类型转换机制" class="headerlink" title="javascript系列-类型转换机制"></a>javascript系列-类型转换机制</h1><h2 id="一、显示转换"><a href="#一、显示转换" class="headerlink" title="一、显示转换"></a>一、显示转换</h2><p>[^常用的方法：Number()，parseInt()，String()，Boolean()]: </p>
<h3 id="1-Number"><a href="#1-Number" class="headerlink" title="1. Number()"></a>1. Number()</h3><p>​    将任意类型转换为数值类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number(234));       // 234</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * 字符串</span><br><span class="line">  * 1. 可以被解析为数值，则会转换为相应的值</span><br><span class="line">  * 2. 不可以被解析为数值，则会转换为NaN</span><br><span class="line">  * 3. 空字符串，返回的是0</span><br><span class="line">  */</span><br><span class="line">console.log(Number(&#x27;345&#x27;));     // 345</span><br><span class="line">console.log(Number(&#x27;456jkl&#x27;));  // NaN</span><br><span class="line">console.log(Number(&#x27;&#x27;));        // 0</span><br><span class="line"></span><br><span class="line">// 布尔值，true转为1，false转为0</span><br><span class="line">console.log(Number(true));      // 1</span><br><span class="line">console.log(Number(false));     // 0</span><br><span class="line"></span><br><span class="line">// undefined: 转为NaN</span><br><span class="line">console.log(Number(undefined)); // NaN</span><br><span class="line"></span><br><span class="line">// null: 转为0</span><br><span class="line">console.log(Number(null));      // 0</span><br><span class="line"></span><br><span class="line">// 对象：通常转换为NaN(除了包含单个数值的数组)</span><br><span class="line">console.log(Number(&#123;a: 1&#125;));    // NaN</span><br><span class="line">console.log(Number([1, 2, 3])); // NaN</span><br><span class="line">console.log(Number([1]));       // 1</span><br></pre></td></tr></table></figure>

<h3 id="2-parseInt"><a href="#2-parseInt" class="headerlink" title="2. parseInt()"></a>2. parseInt()</h3><p>​    parseInt()相比Number()，逐个解析字符，遇到字符就会停止解析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(parseInt(&#x27;12a123&#x27;));    // 12</span><br></pre></td></tr></table></figure>

<h3 id="3-String"><a href="#3-String" class="headerlink" title="3. String()"></a>3. String()</h3><p>​    将任意类型的值转为字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 数值: 转为相应的字符串 </span><br><span class="line">console.log(String(1));             // &quot;1&quot;</span><br><span class="line"></span><br><span class="line">// 字符串：转换后还是原来的值</span><br><span class="line">console.log(String(&#x27;a&#x27;));           // &quot;a&quot;</span><br><span class="line"></span><br><span class="line">// 布尔值：true转为&quot;true&quot;，false转为&quot;false&quot;</span><br><span class="line">console.log(String(true), String(false)); // true false</span><br><span class="line"></span><br><span class="line">// undefined: 转为字符串&quot;undefined&quot;</span><br><span class="line">console.log(String(undefined));     // &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">// null: 转为&quot;null&quot;</span><br><span class="line">console.log(String(null));          // &quot;null&quot;</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">console.log(String(&#123;a: 1, b: 2&#125;));  // &quot;[Object, Object]&quot;</span><br><span class="line">console.log(String([1, 2, 3]));             // &quot;1,2,3&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-Boolean"><a href="#4-Boolean" class="headerlink" title="4. Boolean()"></a>4. Boolean()</h3><pre><code> 将任意类型的值转为布尔值。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(Boolean(undefined));       // false</span><br><span class="line">console.log(Boolean(null));            // false</span><br><span class="line">console.log(Boolean(0));               // false</span><br><span class="line">console.log(Boolean(NaN));             // false</span><br><span class="line">console.log(Boolean(&#x27;&#x27;));              // false</span><br><span class="line">console.log(Boolean(&#123;&#125;));              // true</span><br><span class="line">console.log(Boolean([]));              // true</span><br><span class="line">console.log(Boolean(new Boolean(false)));   // true</span><br></pre></td></tr></table></figure>

<h2 id="二、隐式转换"><a href="#二、隐式转换" class="headerlink" title="二、隐式转换"></a>二、隐式转换</h2><p>+，-，*，/，%</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 1. 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串</span><br><span class="line">// 具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串</span><br><span class="line">&#x27;5&#x27; + 1 // &#x27;51&#x27;</span><br><span class="line">&#x27;5&#x27; + true // &quot;5true&quot;</span><br><span class="line">&#x27;5&#x27; + false // &quot;5false&quot;</span><br><span class="line">&#x27;5&#x27; + &#123;&#125; // &quot;5[object Object]&quot;</span><br><span class="line">&#x27;5&#x27; + [] // &quot;5&quot;</span><br><span class="line">&#x27;5&#x27; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;</span><br><span class="line">&#x27;5&#x27; + undefined // &quot;5undefined&quot;</span><br><span class="line">&#x27;5&#x27; + null // &quot;5null&quot;</span><br><span class="line"></span><br><span class="line">// 2. 除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值,null转为数值时，值为0 // undefined转为数值时，值为NaN</span><br><span class="line">&#x27;5&#x27; - &#x27;2&#x27; // 3</span><br><span class="line">&#x27;5&#x27; * &#x27;2&#x27; // 10</span><br><span class="line">true - 1  // 0</span><br><span class="line">false - 1 // -1</span><br><span class="line">&#x27;1&#x27; - 1   // 0</span><br><span class="line">&#x27;5&#x27; * []    // 0</span><br><span class="line">false / &#x27;5&#x27; // 0</span><br><span class="line">&#x27;abc&#x27; - 1   // NaN</span><br><span class="line">null + 1 // 1</span><br><span class="line">undefined + 1 // NaN</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/31/javascript%E7%B3%BB%E5%88%97-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6/" data-id="ckuxzwzs4000f50vme9ve63ah" data-title="javascript系列-类型转换机制" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-常用字符串的方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/28/javascript%E7%B3%BB%E5%88%97-%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-05-28T01:16:35.000Z" itemprop="datePublished">2021-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/28/javascript%E7%B3%BB%E5%88%97-%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/">javascript系列-常用字符串的方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="javascript系列-字符串常用的方法"><a href="#javascript系列-字符串常用的方法" class="headerlink" title="javascript系列-字符串常用的方法"></a>javascript系列-字符串常用的方法</h1><h2 id="一、操作方法"><a href="#一、操作方法" class="headerlink" title="一、操作方法"></a>一、操作方法</h2><h3 id="1-增"><a href="#1-增" class="headerlink" title="1. 增"></a>1. 增</h3><h4 id="（1）concat"><a href="#（1）concat" class="headerlink" title="（1）concat()"></a>（1）concat()</h4><p>​    concat()将一个字符串或多个字符串拼接成一个新的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27;Hello&#x27;;</span><br><span class="line">let result = stringValue.concat(&#x27; World&#x27;);</span><br><span class="line">console.log(result, stringValue);  // Hello World hello</span><br></pre></td></tr></table></figure>

<h3 id="2-删"><a href="#2-删" class="headerlink" title="2. 删"></a>2. 删</h3><h4 id="（1）slice-，substr-，substring"><a href="#（1）slice-，substr-，substring" class="headerlink" title="（1）slice()，substr()，substring()"></a>（1）slice()，substr()，substring()</h4><p>​    这三个方法都返回调用它们字符串的一个子字符串，而且都接收一个或两个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27;Hello World&#x27;;</span><br><span class="line">console.log(stringValue.slice(3));        // lo World</span><br><span class="line">console.log(stringValue.substr(3));       // lo World</span><br><span class="line">console.log(stringValue.substring(3));    // lo World</span><br><span class="line"></span><br><span class="line">console.log(stringValue.slice(3, 5));     // lo</span><br><span class="line">console.log(stringValue.substr(3, 5));    // lo Wo   第二个参数是截取的个数，不是下标</span><br><span class="line">console.log(stringValue.substring(3, 5)); // lo</span><br></pre></td></tr></table></figure>

<h3 id="3-改"><a href="#3-改" class="headerlink" title="3. 改"></a>3. 改</h3><h4 id="（1）trim-，trimLeft-，trimRight"><a href="#（1）trim-，trimLeft-，trimRight" class="headerlink" title="（1）trim()，trimLeft()，trimRight()"></a>（1）trim()，trimLeft()，trimRight()</h4><p>​    删除前、后或者前后所有空格符，再返回新的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27; Hello World! &#x27;; </span><br><span class="line">console.log(stringValue.trim());      // Hello World!</span><br><span class="line">console.log(stringValue.trimLeft());  // Hello World! </span><br><span class="line">console.log(stringValue.trimRight()); //  Hello World!</span><br></pre></td></tr></table></figure>

<h4 id="（2）repeat"><a href="#（2）repeat" class="headerlink" title="（2）repeat()"></a>（2）repeat()</h4><p>​    接收一个整数参数，表示字符串要复制多少次，然后返回拼接所有副本的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27;Hello&#x27;;</span><br><span class="line">console.log(stringValue.repeat(2)); // HelloHello</span><br></pre></td></tr></table></figure>

<h4 id="（3）padStart"><a href="#（3）padStart" class="headerlink" title="（3）padStart()"></a>（3）padStart()</h4><p>​    复制字符串，在相应一边填充字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27;foo&#x27;;</span><br><span class="line">console.log(stringValue.padStart(6));         //    foo 默认补三个空格</span><br><span class="line">console.log(stringValue.padStart(6, &#x27;,&#x27;));    // ,,,foo</span><br></pre></td></tr></table></figure>

<h4 id="（4）toLowerCase-，toUpperCase"><a href="#（4）toLowerCase-，toUpperCase" class="headerlink" title="（4）toLowerCase()，toUpperCase()"></a>（4）toLowerCase()，toUpperCase()</h4><p>​    大小写转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27;Hello World&#x27;;</span><br><span class="line">console.log(stringValue.toLowerCase());   // hello world</span><br><span class="line">console.log(stringValue.toUpperCase());   // HELLO WORLD</span><br></pre></td></tr></table></figure>

<h3 id="4-查"><a href="#4-查" class="headerlink" title="4. 查"></a>4. 查</h3><h4 id="（1）charAt"><a href="#（1）charAt" class="headerlink" title="（1）charAt()"></a>（1）charAt()</h4><p>​    返回给定索引的字符，由传给方法的整数参数决定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27;Hello World&#x27;;</span><br><span class="line">console.log(stringValue.charAt(2)); // l</span><br></pre></td></tr></table></figure>

<h4 id="（2）indexOf"><a href="#（2）indexOf" class="headerlink" title="（2）indexOf()"></a>（2）indexOf()</h4><p>​    从字符串开头去查找传入的字符串，并返回位置（未找到则返回-1）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27;Hello World&#x27;;</span><br><span class="line">console.log(stringValue.indexOf(&#x27;l&#x27;));  // 2</span><br></pre></td></tr></table></figure>

<h4 id="（3）startWith-，includes"><a href="#（3）startWith-，includes" class="headerlink" title="（3）startWith()，includes()"></a>（3）startWith()，includes()</h4><p>​    从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27;foobarbaz&#x27;;</span><br><span class="line">console.log(stringValue.startsWith(&#x27;foo&#x27;));   // true</span><br><span class="line">console.log(stringValue.startsWith(&#x27;bar&#x27;));   // false</span><br><span class="line"></span><br><span class="line">console.log(stringValue.includes(&#x27;bar&#x27;));     // true</span><br><span class="line">console.log(stringValue.includes(&#x27;qux&#x27;));     // false</span><br></pre></td></tr></table></figure>

<h2 id="二、转换方法"><a href="#二、转换方法" class="headerlink" title="二、转换方法"></a>二、转换方法</h2><h3 id="1-split"><a href="#1-split" class="headerlink" title="1. split()"></a>1. split()</h3><p>​    把字符串按照指定的字符拆分成数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let stringValue = &#x27;12+13+14+520&#x27;;</span><br><span class="line">console.log(stringValue.split(&#x27;+&#x27;));  // [ &#x27;12&#x27;, &#x27;13&#x27;, &#x27;14&#x27;, &#x27;520&#x27; ]</span><br></pre></td></tr></table></figure>

<h2 id="三、模板匹配方法"><a href="#三、模板匹配方法" class="headerlink" title="三、模板匹配方法"></a>三、模板匹配方法</h2><h3 id="1-match"><a href="#1-match" class="headerlink" title="1. match()"></a>1. match()</h3><p>​    接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，返回一个数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">const pattern1 = /.at/;</span><br><span class="line">const pattern2 = /.at/g;</span><br><span class="line">console.log(text.match(pattern1));  // [ &#x27;cat&#x27;, index: 0, input: &#x27;cat, bat, sat, fat&#x27;, groups: undefined ]</span><br><span class="line">console.log(text.match(pattern2));  // [ &#x27;cat&#x27;, &#x27;bat&#x27;, &#x27;sat&#x27;, &#x27;fat&#x27; ]</span><br></pre></td></tr></table></figure>

<h3 id="2-search"><a href="#2-search" class="headerlink" title="2. search()"></a>2. search()</h3><p>​    接收一个参数，可以是一个正则表达式字符串，也可以是RegExp对象，找到则返回匹配索引，否则返回的是-1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">const pattern = /.at/;</span><br><span class="line">console.log(text.search(pattern));    // 0</span><br></pre></td></tr></table></figure>

<h3 id="3-replace"><a href="#3-replace" class="headerlink" title="3. replace()"></a>3. replace()</h3><p>​    接收两个参数，第一个参数是匹配的内容，第二个参数为替换的元素（可选）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const text = &#x27;cat, bat, sat, fat&#x27;;</span><br><span class="line">const pattern = /at/g;</span><br><span class="line">console.log(text.replace(pattern, &#x27;on&#x27;));   // con, bon, son, fon</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/28/javascript%E7%B3%BB%E5%88%97-%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/" data-id="ckuxzwzrt000a50vmcquvfssz" data-title="javascript系列-常用字符串的方法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javascript系列-数组常用的方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/27/javascript%E7%B3%BB%E5%88%97-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-05-27T00:56:21.000Z" itemprop="datePublished">2021-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/27/javascript%E7%B3%BB%E5%88%97-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/">javascript系列-数组常用的方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数组常见的方法"><a href="#数组常见的方法" class="headerlink" title="数组常见的方法"></a>数组常见的方法</h1><h2 id="一、操作方法"><a href="#一、操作方法" class="headerlink" title="一、操作方法"></a>一、操作方法</h2><h3 id="1-增"><a href="#1-增" class="headerlink" title="1.    增"></a>1.    增</h3><p>[^前三种对原数组产生影响，最后一种不会产生影响。]: </p>
<h4 id="（1）push"><a href="#（1）push" class="headerlink" title="（1）push()"></a>（1）push()</h4><p>​    push()方法接收任意长度的数组参数，并将其添加至末尾，返回数组的最新长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const colors = [];</span><br><span class="line">const count = colors.push(&#x27;red&#x27;, &#x27;green&#x27;);</span><br><span class="line">console.log(count);	// 2</span><br></pre></td></tr></table></figure>

<h4 id="（2）unshift"><a href="#（2）unshift" class="headerlink" title="（2）unshift()"></a>（2）unshift()</h4><p>​    unshift()方法数组开头添加任意多个值，然后返回最新的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const fruits = [];</span><br><span class="line">const fruitsCount = fruits.unshift(&#x27;apple&#x27;, &#x27;orange&#x27;);</span><br><span class="line">console.log(fruitsCount, fruits); // 2 [ &#x27;apple&#x27;, &#x27;orange&#x27; ]</span><br></pre></td></tr></table></figure>

<h4 id="（3）splice"><a href="#（3）splice" class="headerlink" title="（3）splice()"></a>（3）splice()</h4><p>​    splice()方法传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];</span><br><span class="line">let removed = colors.splice(-1, 0, &#x27;yellow&#x27;, &#x27;black&#x27;);</span><br><span class="line">console.log(removed, colors);   // [] [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;, &#x27;green&#x27; ]</span><br></pre></td></tr></table></figure>

<h4 id="（4）concat"><a href="#（4）concat" class="headerlink" title="（4）concat()"></a>（4）concat()</h4><p>​        首先会创建一个当前数组的副本，然后把它的参数添加到当前数组的末尾，不会影响到原来的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];</span><br><span class="line">let colors2 = colors.concat(&#x27;yellow&#x27;, [&#x27;white&#x27;, &#x27;black&#x27;]);</span><br><span class="line">console.log(colors, colors2); // [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ] [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;black&#x27; ]</span><br></pre></td></tr></table></figure>

<h3 id="2-删"><a href="#2-删" class="headerlink" title="2. 删"></a>2. 删</h3><p>[^前三种都会影响到原来的数组，最后一种不会影响。]: </p>
<h4 id="（1）pop"><a href="#（1）pop" class="headerlink" title="（1）pop()"></a>（1）pop()</h4><p>​    pop()方法用于删除数组的最后一项，同时减少length值，最后返回被删除的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&#x27;red&#x27;, &#x27;green&#x27;];</span><br><span class="line">let item = colors.pop();</span><br><span class="line">console.log(item, colors, colors.length); // green [ &#x27;red&#x27; ] 1</span><br></pre></td></tr></table></figure>

<h4 id="（2）shift"><a href="#（2）shift" class="headerlink" title="（2）shift()"></a>（2）shift()</h4><p>​    shift()方法用于删除数组的第一项，同时减少length值，最后返回被删除的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&#x27;red&#x27;, &#x27;green&#x27;];</span><br><span class="line">let item = colors.shift();</span><br><span class="line">console.log(item, colors, colors.length); // red [ &#x27;green&#x27; ] 1</span><br></pre></td></tr></table></figure>

<h4 id="（3）splice-1"><a href="#（3）splice-1" class="headerlink" title="（3）splice()"></a>（3）splice()</h4><p>​    splice()方法传入两个参数，第一个参数起始位置，第二个参数删除的个数，返回包含删除元素的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];</span><br><span class="line">let removed = colors.splice(1, 1);</span><br><span class="line">console.log(colors, removed); // [ &#x27;red&#x27;, &#x27;blue&#x27; ] [ &#x27;green&#x27; ]</span><br></pre></td></tr></table></figure>

<h4 id="（4）slice"><a href="#（4）slice" class="headerlink" title="（4）slice()"></a>（4）slice()</h4><p>​    slice()方法用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原来数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;white&#x27;, &#x27;black&#x27;];</span><br><span class="line">let colors2 = colors.slice(1);</span><br><span class="line">let colors3 = colors.slice(1, 4);</span><br><span class="line"></span><br><span class="line">console.log(colors);  // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;white&#x27;, &#x27;black&#x27; ]</span><br><span class="line">console.log(colors2); // [ &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;white&#x27;, &#x27;black&#x27; ]</span><br><span class="line">console.log(colors3); // [ &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;white&#x27; ]</span><br></pre></td></tr></table></figure>

<h3 id="3-改"><a href="#3-改" class="headerlink" title="3. 改"></a>3. 改</h3><h4 id="（1）splice"><a href="#（1）splice" class="headerlink" title="（1）splice()"></a>（1）splice()</h4><p>​    splice()方法传入三个参数，分别为数组的起始位置，删除数组的个数，插入的元素，返回删除元素的数组，对原数组产生影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;white&#x27;, &#x27;black&#x27;];</span><br><span class="line">let removed = colors.splice(1, 1, &#x27;red&#x27;);</span><br><span class="line">console.log(colors, removed); // [ &#x27;red&#x27;, &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;white&#x27;, &#x27;black&#x27; ] [ &#x27;green&#x27; ]</span><br></pre></td></tr></table></figure>

<h3 id="4-查"><a href="#4-查" class="headerlink" title="4. 查"></a>4. 查</h3><h4 id="（1）indexOf"><a href="#（1）indexOf" class="headerlink" title="（1）indexOf()"></a>（1）indexOf()</h4><p>​    indexOf()方法返回查找的元素在数组中的位置，未找到则返回-1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 3, 4];</span><br><span class="line">const index = numbers.indexOf(3);</span><br><span class="line">console.log(index);   // 2</span><br></pre></td></tr></table></figure>

<h4 id="（2）includes"><a href="#（2）includes" class="headerlink" title="（2）includes()"></a>（2）includes()</h4><p>​    includes()方法返回要查找的元素在数组中的位置，查到返true，否则false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 3, 4];</span><br><span class="line">console.log(numbers.includes(4)); // true</span><br></pre></td></tr></table></figure>

<h4 id="（3）find"><a href="#（3）find" class="headerlink" title="（3）find()"></a>（3）find()</h4><p>​    find()返回第一个匹配的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;Matt&quot;,</span><br><span class="line">    age: 27</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    age: 29</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const item = people.find(el =&gt; el.age &lt; 28);</span><br><span class="line">console.log(item);  // &#123; name: &#x27;Matt&#x27;, age: 27 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、排序方法"><a href="#二、排序方法" class="headerlink" title="二、排序方法"></a>二、排序方法</h2><h3 id="1-reverse"><a href="#1-reverse" class="headerlink" title="1. reverse()"></a>1. reverse()</h3><p>​    将数组元素反方向排列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 4, 2, 3];</span><br><span class="line">numbers.reverse();</span><br><span class="line">console.log(numbers);   // [ 3, 2, 4, 2, 1 ]</span><br></pre></td></tr></table></figure>

<h3 id="2-sort"><a href="#2-sort" class="headerlink" title="2. sort()"></a>2. sort()</h3><p>​    默认情况会按照升序排列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 案例一：sort()会在每一项调用String()转型函数，然后比较字符串来决定顺序。即使5小于10，但字符串&quot;10&quot;在字符串&quot;5&quot;的前头。</span><br><span class="line">const values = [0, 1, 5, 10, 15];</span><br><span class="line">values.sort();</span><br><span class="line">console.log(values);  // [ 0, 1, 10, 15, 5 ]</span><br><span class="line"></span><br><span class="line">// 案例二：</span><br><span class="line">const values = [0, 1, 5, 10, 15];</span><br><span class="line">values.sort((a, b) =&gt; a &lt; b ? -1 : (a &gt; b) ? 1 : 0);</span><br><span class="line">console.log(values);  // [ 0, 1, 5, 10, 15 ]</span><br></pre></td></tr></table></figure>

<h2 id="三、转换方法"><a href="#三、转换方法" class="headerlink" title="三、转换方法"></a>三、转换方法</h2><h3 id="1-join"><a href="#1-join" class="headerlink" title="1. join()"></a>1. join()</h3><p>​    join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];</span><br><span class="line">console.log(colors.join(&#x27;,&#x27;));  // red,blue,green</span><br><span class="line">console.log(colors.join(&#x27;||&#x27;)); // red||blue||green</span><br></pre></td></tr></table></figure>

<h2 id="四、迭代方法"><a href="#四、迭代方法" class="headerlink" title="四、迭代方法"></a>四、迭代方法</h2><p>[^常用的迭代方法都不会改变原数组]: </p>
<h3 id="1-some"><a href="#1-some" class="headerlink" title="1. some()"></a>1. some()</h3><p>​    some()方法对数组的每一项都运行传入的函数，如果有一项函数返回true，则这个方法都返回true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 2];</span><br><span class="line">let numbersResult = numbers.some(item =&gt; item &gt; 2);</span><br><span class="line">console.log(numbersResult); // true</span><br></pre></td></tr></table></figure>

<h3 id="2-every"><a href="#2-every" class="headerlink" title="2. every()"></a>2. every()</h3><p>​    every()方法对数组的每一项都运行传入的函数，如果每一项函数返回true，则这个方法都返回true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 2];</span><br><span class="line">let numbersResult = numbers.every(item =&gt; item &gt; 2);</span><br><span class="line">console.log(numbersResult); // false</span><br></pre></td></tr></table></figure>

<h3 id="3-forEach"><a href="#3-forEach" class="headerlink" title="3. forEach()"></a>3. forEach()</h3><p>​    forEach()方法对数组每一项都运行传入的函数，没有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 2];</span><br><span class="line">numbers.forEach((item, index, arr) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-filter"><a href="#4-filter" class="headerlink" title="4. filter()"></a>4. filter()</h3><p>​    filter()方法对数组每一项都运行传入的函数，函数返回true的项会组成数组之后返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers =  [1, 2, 3, 4, 2];</span><br><span class="line">let filterResult = numbers.filter((item, index, arr) =&gt; item &gt; 1);</span><br><span class="line">console.log(filterResult);  // [ 2, 3, 4, 2 ]</span><br></pre></td></tr></table></figure>

<h3 id="5-map"><a href="#5-map" class="headerlink" title="5. map()"></a>5. map()</h3><p>​    map()对数组的每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers =  [1, 2, 3, 4, 2];</span><br><span class="line">let filterResult = numbers.map((item, index, arr) =&gt; item * 2);</span><br><span class="line">console.log(filterResult);  // [ 2, 4, 6, 8, 4 ]</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/27/javascript%E7%B3%BB%E5%88%97-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/" data-id="ckuxzwzrz000c50vmc1fy787g" data-title="javascript系列-数组常用的方法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/25/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-05-25T01:45:25.111Z" itemprop="datePublished">2021-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/25/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/25/hello-world/" data-id="ckuxzwzqw000050vmdiap4j48" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/19/%E6%96%87%E6%A1%A3-3D/bookmarks_10_19_21/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/19/%E6%96%87%E6%A1%A3-3D/">文档-3D</a>
          </li>
        
          <li>
            <a href="/2021/06/21/javascript%E7%B3%BB%E5%88%97-call%E3%80%81apply%E3%80%81bind/">javascript系列-call、apply、bind</a>
          </li>
        
          <li>
            <a href="/2021/06/17/javascript%E7%B3%BB%E5%88%97-ajax/">javascript系列-ajax</a>
          </li>
        
          <li>
            <a href="/2021/06/16/javascript%E7%B3%BB%E5%88%97-new%E6%93%8D%E4%BD%9C%E7%AC%A6/">javascript系列-new操作符</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>